# **Athena Renderer \- å®Œå…¨é–‹ç™ºãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ**

## **ğŸ“˜ ç›®æ¬¡**

1. [æ¦‚è¦](https://claude.ai/chat/2fdf4e34-fde8-4e4b-b9bd-c606bb56098d#%E6%A6%82%E8%A6%81)  
2. [ã‚³ãƒ³ã‚»ãƒ—ãƒˆ](https://claude.ai/chat/2fdf4e34-fde8-4e4b-b9bd-c606bb56098d#%E3%82%B3%E3%83%B3%E3%82%BB%E3%83%97%E3%83%88)  
3. [ã‚·ã‚¹ãƒ†ãƒ ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£](https://claude.ai/chat/2fdf4e34-fde8-4e4b-b9bd-c606bb56098d#%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0%E3%82%A2%E3%83%BC%E3%82%AD%E3%83%86%E3%82%AF%E3%83%81%E3%83%A3)  
4. [ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆæ§‹æˆ](https://claude.ai/chat/2fdf4e34-fde8-4e4b-b9bd-c606bb56098d#%E3%83%97%E3%83%AD%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E6%A7%8B%E6%88%90)  
5. [ç’°å¢ƒæ§‹ç¯‰](https://claude.ai/chat/2fdf4e34-fde8-4e4b-b9bd-c606bb56098d#%E7%92%B0%E5%A2%83%E6%A7%8B%E7%AF%89)  
6. [ã‚³ã‚¢å®Ÿè£…](https://claude.ai/chat/2fdf4e34-fde8-4e4b-b9bd-c606bb56098d#%E3%82%B3%E3%82%A2%E5%AE%9F%E8%A3%85)  
7. [ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚°ãƒ©ãƒ•ã‚·ã‚¹ãƒ†ãƒ ](https://claude.ai/chat/2fdf4e34-fde8-4e4b-b9bd-c606bb56098d#%E3%83%AC%E3%83%B3%E3%83%80%E3%83%BC%E3%82%B0%E3%83%A9%E3%83%95%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0)  
8. [æ¨™æº–ãƒ¬ãƒ³ãƒ€ãƒ¼ãƒ‘ã‚¹](https://claude.ai/chat/2fdf4e34-fde8-4e4b-b9bd-c606bb56098d#%E6%A8%99%E6%BA%96%E3%83%AC%E3%83%B3%E3%83%80%E3%83%BC%E3%83%91%E3%82%B9)  
9. [ãƒ“ãƒ¥ãƒ¼ã‚¢ãƒ¼ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³](https://claude.ai/chat/2fdf4e34-fde8-4e4b-b9bd-c606bb56098d#%E3%83%93%E3%83%A5%E3%83%BC%E3%82%A2%E3%83%BC%E3%82%A2%E3%83%97%E3%83%AA%E3%82%B1%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3)  
10. [ç ”ç©¶æ©Ÿèƒ½ã®è¿½åŠ æ–¹æ³•](https://claude.ai/chat/2fdf4e34-fde8-4e4b-b9bd-c606bb56098d#%E7%A0%94%E7%A9%B6%E6%A9%9F%E8%83%BD%E3%81%AE%E8%BF%BD%E5%8A%A0%E6%96%B9%E6%B3%95)  
11. [å®Ÿé¨“ãƒ»ãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯](https://claude.ai/chat/2fdf4e34-fde8-4e4b-b9bd-c606bb56098d#%E5%AE%9F%E9%A8%93%E3%83%99%E3%83%B3%E3%83%81%E3%83%9E%E3%83%BC%E3%82%AF)  
12. [é–‹ç™ºãƒ•ãƒ­ãƒ¼](https://claude.ai/chat/2fdf4e34-fde8-4e4b-b9bd-c606bb56098d#%E9%96%8B%E7%99%BA%E3%83%95%E3%83%AD%E3%83%BC)  
13. [è«–æ–‡åŸ·ç­†ã¸ã®å¿œç”¨](https://claude.ai/chat/2fdf4e34-fde8-4e4b-b9bd-c606bb56098d#%E8%AB%96%E6%96%87%E5%9F%B7%E7%AD%86%E3%81%B8%E3%81%AE%E5%BF%9C%E7%94%A8)  
14. [ãƒˆãƒ©ãƒ–ãƒ«ã‚·ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚°](https://claude.ai/chat/2fdf4e34-fde8-4e4b-b9bd-c606bb56098d#%E3%83%88%E3%83%A9%E3%83%96%E3%83%AB%E3%82%B7%E3%83%A5%E3%83%BC%E3%83%86%E3%82%A3%E3%83%B3%E3%82%B0)

---

## **æ¦‚è¦**

**Athena Renderer**ã¯ã€ã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯ã‚¹ç ”ç©¶ã®ãŸã‚ã«è¨­è¨ˆã•ã‚ŒãŸDirectX 12ãƒ™ãƒ¼ã‚¹ã®è»½é‡ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ã§ã™ã€‚çŸ¥æµã®å¥³ç¥ã‚¢ãƒ†ãƒŠã®åã‚’å† ã—ã€ç ”ç©¶è€…ãŒæ–°ã—ã„ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°æŠ€è¡“ã‚’æ¢æ±‚ã—ã€å®Ÿé¨“ã—ã€è«–æ–‡åŒ–ã™ã‚‹ãŸã‚ã®ã€ŒçŸ¥çš„ãªå®Ÿé¨“å ´ã€ã‚’æä¾›ã—ã¾ã™ã€‚

### **ç‰¹å¾´**

âœ“ ãƒ¢ã‚¸ãƒ¥ãƒ©ãƒ¼ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£  
  \- ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚°ãƒ©ãƒ•ã«ã‚ˆã‚‹æŸ”è»Ÿãªãƒ‘ã‚¹æ§‹æˆ  
  \- åŸºç›¤ã‚’å¤‰æ›´ã›ãšã«æ–°æ©Ÿèƒ½ã‚’è¿½åŠ å¯èƒ½

âœ“ ç ”ç©¶æŒ‡å‘è¨­è¨ˆ  
  \- è¿…é€Ÿãªãƒ—ãƒ­ãƒˆã‚¿ã‚¤ãƒ”ãƒ³ã‚°  
  \- å…¬å¹³ãªæ¯”è¼ƒå®Ÿé¨“  
  \- è«–æ–‡åŸ·ç­†ã«æœ€é©

âœ“ é«˜æ€§èƒ½  
  \- DirectX 12ã®æœ€æ–°æ©Ÿèƒ½ã‚’ãƒ•ãƒ«æ´»ç”¨  
  \- GPUé§†å‹•ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°å¯¾å¿œ  
  \- è©³ç´°ãªãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒªãƒ³ã‚°

âœ“ ä½¿ã„ã‚„ã™ã•  
  \- ImGuiãƒ™ãƒ¼ã‚¹ã®å®Ÿé¨“åˆ¶å¾¡UI  
  \- è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ãƒ™ãƒ¼ã‚¹ã®å®Ÿé¨“ç®¡ç†  
  \- è‡ªå‹•ãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯æ©Ÿèƒ½

### **å¯¾è±¡ãƒ¦ãƒ¼ã‚¶ãƒ¼**

* ã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯ã‚¹ç ”ç©¶è€…  
* å¤§å­¦é™¢ç”Ÿãƒ»å­¦éƒ¨ç”Ÿ  
* ã‚²ãƒ¼ãƒ ã‚¨ãƒ³ã‚¸ãƒ³é–‹ç™ºè€…  
* DirectX 12å­¦ç¿’è€…

### **ã‚·ã‚¹ãƒ†ãƒ è¦ä»¶**

OS: Windows 10/11 (64-bit)  
GPU: DirectX 12å¯¾å¿œGPU  
  \- NVIDIA: GTX 1060ä»¥ä¸Šæ¨å¥¨  
  \- AMD: RX 5700ä»¥ä¸Šæ¨å¥¨  
  \- Intel: Arc A750ä»¥ä¸Šæ¨å¥¨  
RAM: 8GBä»¥ä¸Š (16GBæ¨å¥¨)  
VRAM: 4GBä»¥ä¸Š (8GBæ¨å¥¨)  
IDE: Visual Studio 2022  
SDK: Windows SDK 10.0.22000.0ä»¥ä¸Š

---

## **ã‚³ãƒ³ã‚»ãƒ—ãƒˆ**

### **è¨­è¨ˆå“²å­¦**

"ç ”ç©¶è€…ãŒåŸºç›¤ã‚’æ°—ã«ã›ãšã€ã‚¢ã‚¤ãƒ‡ã‚¢ã«é›†ä¸­ã§ãã‚‹ç’°å¢ƒ"

ã€åŸå‰‡ã€‘  
1\. é–¢å¿ƒã®åˆ†é›¢ (Separation of Concerns)  
   \- å„ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¯ç‹¬ç«‹ã—ãŸè²¬ä»»  
   \- ä½ãƒ¬ãƒ™ãƒ«ã¨é«˜ãƒ¬ãƒ™ãƒ«ã®æ˜ç¢ºãªåˆ†é›¢

2\. é–‹æ”¾é–‰é–åŸå‰‡ (Open-Closed Principle)  
   \- æ‹¡å¼µã«å¯¾ã—ã¦é–‹ã„ã¦ã„ã‚‹  
   \- ä¿®æ­£ã«å¯¾ã—ã¦é–‰ã˜ã¦ã„ã‚‹

3\. ä¾å­˜æ€§æ³¨å…¥ (Dependency Injection)  
   \- ä¾å­˜é–¢ä¿‚ã¯å¤–éƒ¨ã‹ã‚‰æ³¨å…¥  
   \- ãƒ†ã‚¹ã‚¿ãƒ“ãƒªãƒ†ã‚£ã®å‘ä¸Š

### **Athena Rendererã®ä½ç½®ã¥ã‘**

ã€æ¯”è¼ƒã€‘

Unity/Unreal Engine  
â”œâ”€ å®Œå…¨ãªã‚²ãƒ¼ãƒ é–‹ç™ºç’°å¢ƒ  
â”œâ”€ ãƒ–ãƒ©ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ãŒå¤šã„  
â””â”€ ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã«åˆ¶é™

Falcor (NVIDIA)  
â”œâ”€ ç ”ç©¶ç”¨ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯  
â”œâ”€ å¤§è¦æ¨¡ãƒ»æ©Ÿèƒ½è±Šå¯Œ  
â””â”€ å­¦ç¿’ã‚³ã‚¹ãƒˆãŒé«˜ã„

Athena Renderer â† ã‚ãªãŸãŒä½œã‚‹ã‚‚ã®  
â”œâ”€ ç ”ç©¶ç”¨ã®å®Ÿé¨“å°  
â”œâ”€ è»½é‡ãƒ»ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºé‡è¦–  
â”œâ”€ ç†è§£ã—ã‚„ã™ã„è¦æ¨¡  
â””â”€ DirectX 12ã®æ·±ã„ç†è§£

ã€ç”¨é€”ã€‘  
âœ“ æ–°ã—ã„ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°æŠ€è¡“ã®ç ”ç©¶  
âœ“ å­¦è¡“è«–æ–‡ã®å®Ÿè£…åŸºç›¤  
âœ“ DirectX 12ã®å­¦ç¿’  
âœ“ ãƒãƒ¼ãƒˆãƒ•ã‚©ãƒªã‚ªä½œå“

---

## **ã‚·ã‚¹ãƒ†ãƒ ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£**

### **ãƒ¬ã‚¤ãƒ¤ãƒ¼æ§‹é€ **

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  
â”‚  Application Layer (ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³å±¤)     â”‚  
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚  
â”‚  â”‚ \- AthenaViewer (ãƒ“ãƒ¥ãƒ¼ã‚¢ãƒ¼ã‚¢ãƒ—ãƒª)   â”‚   â”‚  
â”‚  â”‚ \- Experiment Runner (å®Ÿé¨“ãƒ„ãƒ¼ãƒ«)    â”‚   â”‚  
â”‚  â”‚ \- Benchmark Scripts                 â”‚   â”‚  
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚  
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  
â”‚  Research Layer (ç ”ç©¶ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«å±¤)          â”‚  
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚  
â”‚  â”‚ \- Neural Rendering                  â”‚   â”‚  
â”‚  â”‚ \- GPU-Driven Culling                â”‚   â”‚  
â”‚  â”‚ \- Adaptive Rendering                â”‚   â”‚  
â”‚  â”‚ \- Custom Passes                     â”‚   â”‚  
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚  
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  
â”‚  Render Graph Layer (ãƒ‘ã‚¹ç®¡ç†å±¤)            â”‚  
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚  
â”‚  â”‚ \- Dependency Resolution             â”‚   â”‚  
â”‚  â”‚ \- Resource Lifetime Management      â”‚   â”‚  
â”‚  â”‚ \- Automatic Optimization            â”‚   â”‚  
â”‚  â”‚ \- Pass Execution                    â”‚   â”‚  
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚  
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  
â”‚  Abstraction Layer (æŠ½è±¡åŒ–å±¤)               â”‚  
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚  
â”‚  â”‚ \- Device Management                 â”‚   â”‚  
â”‚  â”‚ \- Resource Management               â”‚   â”‚  
â”‚  â”‚ \- Command Management                â”‚   â”‚  
â”‚  â”‚ \- Descriptor Management             â”‚   â”‚  
â”‚  â”‚ \- Pipeline Management               â”‚   â”‚  
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚  
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  
â”‚  DirectX 12 API                             â”‚  
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

### **ãƒ‡ãƒ¼ã‚¿ãƒ•ãƒ­ãƒ¼**

åˆæœŸåŒ–ãƒ•ã‚§ãƒ¼ã‚º:  
  Device â†’ CommandQueue â†’ SwapChain â†’ DescriptorHeaps

ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ãƒ•ã‚§ãƒ¼ã‚º:  
  RenderGraph.Compile()  
    â†“  
  ä¾å­˜é–¢ä¿‚è§£æ±º  
    â†“  
  ãƒªã‚½ãƒ¼ã‚¹ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ è§£æ  
    â†“  
  ãƒ¡ãƒ¢ãƒªæœ€é©åŒ–  
    â†“  
  RenderGraph.Execute()  
    â†“  
  å„Pass.Execute(context)  
    â†“  
  SwapChain.Present()

---

## **ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆæ§‹æˆ**

### **ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªæ§‹é€ **

athena-renderer/  
â”œâ”€ AthenaRenderer.sln                 \# Visual Studioã‚½ãƒªãƒ¥ãƒ¼ã‚·ãƒ§ãƒ³  
â”‚  
â”œâ”€ AthenaCore/                        \# ã‚³ã‚¢ãƒ©ã‚¤ãƒ–ãƒ©ãƒªãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆ  
â”‚  â”œâ”€ AthenaCore.vcxproj  
â”‚  â”œâ”€ AthenaCore.vcxproj.filters  
â”‚  â”‚  
â”‚  â”œâ”€ include/  
â”‚  â”‚  â””â”€ Athena/  
â”‚  â”‚     â”œâ”€ Core/  
â”‚  â”‚     â”‚  â”œâ”€ Device.h              \# ãƒ‡ãƒã‚¤ã‚¹ç®¡ç†  
â”‚  â”‚     â”‚  â”œâ”€ CommandQueue.h        \# ã‚³ãƒãƒ³ãƒ‰ã‚­ãƒ¥ãƒ¼  
â”‚  â”‚     â”‚  â”œâ”€ CommandList.h         \# ã‚³ãƒãƒ³ãƒ‰ãƒªã‚¹ãƒˆ  
â”‚  â”‚     â”‚  â”œâ”€ SwapChain.h           \# ã‚¹ãƒ¯ãƒƒãƒ—ãƒã‚§ãƒ¼ãƒ³  
â”‚  â”‚     â”‚  â”œâ”€ DescriptorHeap.h     \# ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ç®¡ç†  
â”‚  â”‚     â”‚  â””â”€ Fence.h               \# åŒæœŸæ©Ÿæ§‹  
â”‚  â”‚     â”‚  
â”‚  â”‚     â”œâ”€ Resources/  
â”‚  â”‚     â”‚  â”œâ”€ Buffer.h              \# ãƒãƒƒãƒ•ã‚¡æŠ½è±¡åŒ–  
â”‚  â”‚     â”‚  â”œâ”€ Texture.h             \# ãƒ†ã‚¯ã‚¹ãƒãƒ£æŠ½è±¡åŒ–  
â”‚  â”‚     â”‚  â”œâ”€ ResourceManager.h    \# ãƒªã‚½ãƒ¼ã‚¹ç®¡ç†  
â”‚  â”‚     â”‚  â””â”€ UploadContext.h      \# ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ç®¡ç†  
â”‚  â”‚     â”‚  
â”‚  â”‚     â”œâ”€ Rendering/  
â”‚  â”‚     â”‚  â”œâ”€ Shader.h              \# ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ç®¡ç†  
â”‚  â”‚     â”‚  â”œâ”€ Pipeline.h            \# PSOç®¡ç†  
â”‚  â”‚     â”‚  â”œâ”€ RootSignature.h      \# ãƒ«ãƒ¼ãƒˆã‚·ã‚°ãƒãƒãƒ£  
â”‚  â”‚     â”‚  â””â”€ RenderContext.h      \# ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆ  
â”‚  â”‚     â”‚  
â”‚  â”‚     â”œâ”€ RenderGraph/  
â”‚  â”‚     â”‚  â”œâ”€ RenderGraph.h         \# ã‚°ãƒ©ãƒ•æœ¬ä½“  
â”‚  â”‚     â”‚  â”œâ”€ RenderPass.h          \# ãƒ‘ã‚¹åŸºåº•ã‚¯ãƒ©ã‚¹  
â”‚  â”‚     â”‚  â”œâ”€ RenderGraphBuilder.h \# ã‚°ãƒ©ãƒ•æ§‹ç¯‰  
â”‚  â”‚     â”‚  â”œâ”€ ResourceHandle.h     \# ãƒªã‚½ãƒ¼ã‚¹ãƒãƒ³ãƒ‰ãƒ«  
â”‚  â”‚     â”‚  â””â”€ PassRegistry.h       \# ãƒ‘ã‚¹ç™»éŒ²  
â”‚  â”‚     â”‚  
â”‚  â”‚     â”œâ”€ Scene/  
â”‚  â”‚     â”‚  â”œâ”€ Mesh.h                \# ãƒ¡ãƒƒã‚·ãƒ¥  
â”‚  â”‚     â”‚  â”œâ”€ Material.h            \# ãƒãƒ†ãƒªã‚¢ãƒ«  
â”‚  â”‚     â”‚  â”œâ”€ Camera.h              \# ã‚«ãƒ¡ãƒ©  
â”‚  â”‚     â”‚  â”œâ”€ Light.h               \# ãƒ©ã‚¤ãƒˆ  
â”‚  â”‚     â”‚  â””â”€ Scene.h               \# ã‚·ãƒ¼ãƒ³ç®¡ç†  
â”‚  â”‚     â”‚  
â”‚  â”‚     â”œâ”€ Utils/  
â”‚  â”‚     â”‚  â”œâ”€ Math.h                \# æ•°å­¦ãƒ©ã‚¤ãƒ–ãƒ©ãƒª  
â”‚  â”‚     â”‚  â”œâ”€ Timer.h               \# ã‚¿ã‚¤ãƒãƒ¼  
â”‚  â”‚     â”‚  â”œâ”€ Logger.h              \# ãƒ­ã‚°  
â”‚  â”‚     â”‚  â””â”€ Profiler.h            \# ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ©  
â”‚  â”‚     â”‚  
â”‚  â”‚     â””â”€ Athena.h                 \# çµ±åˆãƒ˜ãƒƒãƒ€ãƒ¼  
â”‚  â”‚  
â”‚  â””â”€ src/  
â”‚     â””â”€ Athena/  
â”‚        â”œâ”€ Core/  
â”‚        â”‚  â”œâ”€ Device.cpp  
â”‚        â”‚  â”œâ”€ CommandQueue.cpp  
â”‚        â”‚  â”œâ”€ CommandList.cpp  
â”‚        â”‚  â”œâ”€ SwapChain.cpp  
â”‚        â”‚  â”œâ”€ DescriptorHeap.cpp  
â”‚        â”‚  â””â”€ Fence.cpp  
â”‚        â”‚  
â”‚        â”œâ”€ Resources/  
â”‚        â”‚  â”œâ”€ Buffer.cpp  
â”‚        â”‚  â”œâ”€ Texture.cpp  
â”‚        â”‚  â”œâ”€ ResourceManager.cpp  
â”‚        â”‚  â””â”€ UploadContext.cpp  
â”‚        â”‚  
â”‚        â”œâ”€ Rendering/  
â”‚        â”‚  â”œâ”€ Shader.cpp  
â”‚        â”‚  â”œâ”€ Pipeline.cpp  
â”‚        â”‚  â”œâ”€ RootSignature.cpp  
â”‚        â”‚  â””â”€ RenderContext.cpp  
â”‚        â”‚  
â”‚        â”œâ”€ RenderGraph/  
â”‚        â”‚  â”œâ”€ RenderGraph.cpp  
â”‚        â”‚  â”œâ”€ RenderPass.cpp  
â”‚        â”‚  â”œâ”€ RenderGraphBuilder.cpp  
â”‚        â”‚  â”œâ”€ ResourceHandle.cpp  
â”‚        â”‚  â””â”€ PassRegistry.cpp  
â”‚        â”‚  
â”‚        â”œâ”€ Scene/  
â”‚        â”‚  â”œâ”€ Mesh.cpp  
â”‚        â”‚  â”œâ”€ Material.cpp  
â”‚        â”‚  â”œâ”€ Camera.cpp  
â”‚        â”‚  â”œâ”€ Light.cpp  
â”‚        â”‚  â””â”€ Scene.cpp  
â”‚        â”‚  
â”‚        â””â”€ Utils/  
â”‚           â”œâ”€ Timer.cpp  
â”‚           â”œâ”€ Logger.cpp  
â”‚           â””â”€ Profiler.cpp  
â”‚  
â”œâ”€ AthenaViewer/                      \# ãƒ“ãƒ¥ãƒ¼ã‚¢ãƒ¼ã‚¢ãƒ—ãƒª  
â”‚  â”œâ”€ AthenaViewer.vcxproj  
â”‚  â”œâ”€ main.cpp                        \# ã‚¨ãƒ³ãƒˆãƒªãƒ¼ãƒã‚¤ãƒ³ãƒˆ  
â”‚  â”œâ”€ ViewerApp.h  
â”‚  â”œâ”€ ViewerApp.cpp                   \# ãƒ¡ã‚¤ãƒ³ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³  
â”‚  â”‚  
â”‚  â”œâ”€ UI/  
â”‚  â”‚  â”œâ”€ ImGuiManager.h  
â”‚  â”‚  â”œâ”€ ImGuiManager.cpp             \# ImGuiç®¡ç†  
â”‚  â”‚  â”œâ”€ DebugPanel.h  
â”‚  â”‚  â”œâ”€ DebugPanel.cpp               \# ãƒ‡ãƒãƒƒã‚°UI  
â”‚  â”‚  â”œâ”€ PerformancePanel.h  
â”‚  â”‚  â””â”€ PerformancePanel.cpp         \# ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹UI  
â”‚  â”‚  
â”‚  â”œâ”€ Scenes/  
â”‚  â”‚  â”œâ”€ TestScene.h  
â”‚  â”‚  â”œâ”€ TestScene.cpp                \# ãƒ†ã‚¹ãƒˆã‚·ãƒ¼ãƒ³  
â”‚  â”‚  â”œâ”€ BenchmarkScene.h  
â”‚  â”‚  â””â”€ BenchmarkScene.cpp           \# ãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯ç”¨  
â”‚  â”‚  
â”‚  â””â”€ Passes/                         \# æ¨™æº–ãƒ¬ãƒ³ãƒ€ãƒ¼ãƒ‘ã‚¹  
â”‚     â”œâ”€ GeometryPass.h  
â”‚     â”œâ”€ GeometryPass.cpp  
â”‚     â”œâ”€ LightingPass.h  
â”‚     â”œâ”€ LightingPass.cpp  
â”‚     â”œâ”€ ToneMappingPass.h  
â”‚     â””â”€ ToneMappingPass.cpp  
â”‚  
â”œâ”€ AthenaResearch/                    \# ç ”ç©¶ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«(ã‚ªãƒ—ã‚·ãƒ§ãƒ³)  
â”‚  â”œâ”€ AthenaResearch.vcxproj  
â”‚  â”‚  
â”‚  â”œâ”€ NeuralRendering/  
â”‚  â”‚  â”œâ”€ NeuralGIPass.h  
â”‚  â”‚  â”œâ”€ NeuralGIPass.cpp  
â”‚  â”‚  â””â”€ shaders/  
â”‚  â”‚     â””â”€ neural\_inference.hlsl  
â”‚  â”‚  
â”‚  â”œâ”€ GPUDriven/  
â”‚  â”‚  â”œâ”€ GPUCullingPass.h  
â”‚  â”‚  â”œâ”€ GPUCullingPass.cpp  
â”‚  â”‚  â””â”€ shaders/  
â”‚  â”‚     â””â”€ culling.hlsl  
â”‚  â”‚  
â”‚  â””â”€ AdaptiveRendering/  
â”‚     â”œâ”€ MotionVectorPass.h  
â”‚     â”œâ”€ MotionVectorPass.cpp  
â”‚     â””â”€ shaders/  
â”‚        â””â”€ motion.hlsl  
â”‚  
â”œâ”€ shaders/                           \# å…±é€šã‚·ã‚§ãƒ¼ãƒ€ãƒ¼  
â”‚  â”œâ”€ Common.hlsli                    \# å…±é€šãƒ˜ãƒƒãƒ€ãƒ¼  
â”‚  â”œâ”€ VertexLayouts.hlsli             \# é ‚ç‚¹ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ  
â”‚  â”œâ”€ Lighting.hlsli                  \# ãƒ©ã‚¤ãƒ†ã‚£ãƒ³ã‚°é–¢æ•°  
â”‚  â”œâ”€ BasicVS.hlsl                    \# åŸºæœ¬é ‚ç‚¹ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼  
â”‚  â”œâ”€ BasicPS.hlsl                    \# åŸºæœ¬ãƒ”ã‚¯ã‚»ãƒ«ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼  
â”‚  â”œâ”€ DeferredLightingPS.hlsl        \# ãƒ‡ã‚£ãƒ•ã‚¡ãƒ¼ãƒ‰ãƒ©ã‚¤ãƒ†ã‚£ãƒ³ã‚°  
â”‚  â”œâ”€ ToneMappingPS.hlsl             \# ãƒˆãƒ¼ãƒ³ãƒãƒƒãƒ”ãƒ³ã‚°  
â”‚  â””â”€ FullscreenVS.hlsl              \# ãƒ•ãƒ«ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚¯ãƒ¯ãƒƒãƒ‰  
â”‚  
â”œâ”€ configs/                           \# è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«  
â”‚  â”œâ”€ standard.json                   \# æ¨™æº–ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³  
â”‚  â”œâ”€ deferred.json                   \# ãƒ‡ã‚£ãƒ•ã‚¡ãƒ¼ãƒ‰  
â”‚  â”œâ”€ forward\_plus.json               \# Forward+  
â”‚  â”œâ”€ neural\_gi.json                  \# ãƒ‹ãƒ¥ãƒ¼ãƒ©ãƒ«GIå®Ÿé¨“  
â”‚  â””â”€ gpu\_driven.json                 \# GPUé§†å‹•å®Ÿé¨“  
â”‚  
â”œâ”€ experiments/                       \# å®Ÿé¨“ã‚¹ã‚¯ãƒªãƒ—ãƒˆ  
â”‚  â”œâ”€ benchmark\_runner.cpp            \# ãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯å®Ÿè¡Œ  
â”‚  â”œâ”€ experiment\_config.json          \# å®Ÿé¨“è¨­å®š  
â”‚  â””â”€ results/                        \# å®Ÿé¨“çµæœä¿å­˜å…ˆ  
â”‚     â”œâ”€ csv/  
â”‚     â”œâ”€ graphs/  
â”‚     â””â”€ screenshots/  
â”‚  
â”œâ”€ external/                          \# å¤–éƒ¨ãƒ©ã‚¤ãƒ–ãƒ©ãƒª  
â”‚  â”œâ”€ imgui/                          \# Dear ImGui (submodule)  
â”‚  â”œâ”€ stb/                            \# STB (submodule)  
â”‚  â””â”€ json/                           \# nlohmann/json (submodule)  
â”‚  
â”œâ”€ assets/                            \# ã‚¢ã‚»ãƒƒãƒˆ  
â”‚  â”œâ”€ models/                         \# 3Dãƒ¢ãƒ‡ãƒ«  
â”‚  â”‚  â”œâ”€ sponza/  
â”‚  â”‚  â”œâ”€ bistro/  
â”‚  â”‚  â””â”€ test\_objects/  
â”‚  â”œâ”€ textures/                       \# ãƒ†ã‚¯ã‚¹ãƒãƒ£  
â”‚  â””â”€ fonts/                          \# ãƒ•ã‚©ãƒ³ãƒˆ  
â”‚     â””â”€ Roboto-Regular.ttf  
â”‚  
â”œâ”€ docs/                              \# ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ  
â”‚  â”œâ”€ GettingStarted.md               \# å…¥é–€ã‚¬ã‚¤ãƒ‰  
â”‚  â”œâ”€ Architecture.md                 \# ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£  
â”‚  â”œâ”€ RenderGraph.md                  \# ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚°ãƒ©ãƒ•  
â”‚  â”œâ”€ AddingPasses.md                 \# ãƒ‘ã‚¹è¿½åŠ æ–¹æ³•  
â”‚  â”œâ”€ Benchmarking.md                 \# ãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯  
â”‚  â””â”€ API/                            \# APIè©³ç´°  
â”‚     â”œâ”€ Core.md  
â”‚     â”œâ”€ RenderGraph.md  
â”‚     â””â”€ Resources.md  
â”‚  
â”œâ”€ AthenaCommon.props                 \# å…±é€šãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚·ãƒ¼ãƒˆ  
â”œâ”€ .gitignore  
â”œâ”€ .gitmodules                        \# Submoduleè¨­å®š  
â”œâ”€ README.md  
â””â”€ LICENSE

---

## **ç’°å¢ƒæ§‹ç¯‰**

### **å¿…è¦ãªã‚½ãƒ•ãƒˆã‚¦ã‚§ã‚¢**

1\. Visual Studio 2022  
   \- ãƒ¯ãƒ¼ã‚¯ãƒ­ãƒ¼ãƒ‰: C++ã«ã‚ˆã‚‹ãƒ‡ã‚¹ã‚¯ãƒˆãƒƒãƒ—é–‹ç™º  
   \- ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ:  
     âœ“ MSVC v143  
     âœ“ Windows 10/11 SDK (æœ€æ–°)  
     âœ“ C++ CMake tools (ã‚ªãƒ—ã‚·ãƒ§ãƒ³)

2\. Windows SDK  
   \- ãƒãƒ¼ã‚¸ãƒ§ãƒ³: 10.0.22000.0ä»¥ä¸Š  
   \- DirectX 12 Agility SDKæ¨å¥¨

3\. Git  
   \- Submoduleã§å¤–éƒ¨ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’ç®¡ç†

4\. ã‚ªãƒ—ã‚·ãƒ§ãƒ³:  
   \- PIX for Windows (GPUãƒ‡ãƒãƒƒã‚°)  
   \- RenderDoc (GPUãƒ‡ãƒãƒƒã‚°)  
   \- NVIDIA Nsight Graphics (NVIDIA GPU)

### **ãƒªãƒã‚¸ãƒˆãƒªã®ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—**

\# ãƒªãƒã‚¸ãƒˆãƒªã‚’ã‚¯ãƒ­ãƒ¼ãƒ³  
git clone https://github.com/yourname/athena-renderer.git  
cd athena-renderer

\# Submoduleã‚’åˆæœŸåŒ–  
git submodule update \--init \--recursive

\# Visual Studioã§ã‚½ãƒªãƒ¥ãƒ¼ã‚·ãƒ§ãƒ³ã‚’é–‹ã  
start AthenaRenderer.sln

### **å¤–éƒ¨ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®è¨­å®š**

#### **NuGetãƒ‘ãƒƒã‚±ãƒ¼ã‚¸**

Visual Studioã§ä»¥ä¸‹ã‚’ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«:

ãƒ„ãƒ¼ãƒ« â†’ NuGetãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ â†’   
ã‚½ãƒªãƒ¥ãƒ¼ã‚·ãƒ§ãƒ³ã®NuGetãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã®ç®¡ç†

æ¨å¥¨ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸:  
\- Microsoft.Direct3D.D3D12 (Agility SDK)  
\- DirectXTex\_Desktop\_2019  
\- Assimp (ã‚ªãƒ—ã‚·ãƒ§ãƒ³)  
\- nlohmann.json

#### **Git Submodule**

\# Dear ImGui  
cd external  
git submodule add https://github.com/ocornut/imgui.git imgui

\# STB (ç”»åƒãƒ­ãƒ¼ãƒ€ãƒ¼)  
git submodule add https://github.com/nothings/stb.git stb

\# nlohmann/json  
git submodule add https://github.com/nlohmann/json.git json

### **ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚·ãƒ¼ãƒˆã®è¨­å®š**

**AthenaCommon.props**ã‚’ä½œæˆ:

\<?xml version="1.0" encoding="utf-8"?\>  
\<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003"\>  
  \<PropertyGroup Label="UserMacros"\>  
    \<AthenaRootDir\>$(SolutionDir)\</AthenaRootDir\>  
    \<AthenaIncludeDir\>$(AthenaRootDir)AthenaCore\\include\</AthenaIncludeDir\>  
    \<ExternalDir\>$(AthenaRootDir)external\</ExternalDir\>  
    \<BinDir\>$(AthenaRootDir)bin\\$(Platform)\\$(Configuration)\\\</BinDir\>  
    \<ObjDir\>$(AthenaRootDir)obj\\$(Platform)\\$(Configuration)\\$(ProjectName)\\\</ObjDir\>  
  \</PropertyGroup\>  
    
  \<PropertyGroup\>  
    \<OutDir\>$(BinDir)\</OutDir\>  
    \<IntDir\>$(ObjDir)\</IntDir\>  
  \</PropertyGroup\>  
    
  \<ItemDefinitionGroup\>  
    \<ClCompile\>  
      \<LanguageStandard\>stdcpp20\</LanguageStandard\>  
      \<LanguageStandard\_C\>stdc17\</LanguageStandard\_C\>  
      \<MultiProcessorCompilation\>true\</MultiProcessorCompilation\>  
      \<WarningLevel\>Level4\</WarningLevel\>  
      \<AdditionalIncludeDirectories\>  
        $(AthenaIncludeDir);  
        $(ExternalDir)\\imgui;  
        $(ExternalDir)\\imgui\\backends;  
        $(ExternalDir)\\stb;  
        $(ExternalDir)\\json\\include;  
        %(AdditionalIncludeDirectories)  
      \</AdditionalIncludeDirectories\>  
      \<PreprocessorDefinitions\>  
        WIN32;  
        \_WINDOWS;  
        UNICODE;  
        \_UNICODE;  
        %(PreprocessorDefinitions)  
      \</PreprocessorDefinitions\>  
    \</ClCompile\>  
  \</ItemDefinitionGroup\>  
    
  \<ItemDefinitionGroup Condition="'$(Configuration)'=='Debug'"\>  
    \<ClCompile\>  
      \<Optimization\>Disabled\</Optimization\>  
      \<PreprocessorDefinitions\>\_DEBUG;%(PreprocessorDefinitions)\</PreprocessorDefinitions\>  
      \<RuntimeLibrary\>MultiThreadedDebugDLL\</RuntimeLibrary\>  
    \</ClCompile\>  
  \</ItemDefinitionGroup\>  
    
  \<ItemDefinitionGroup Condition="'$(Configuration)'=='Release'"\>  
    \<ClCompile\>  
      \<Optimization\>MaxSpeed\</Optimization\>  
      \<PreprocessorDefinitions\>NDEBUG;%(PreprocessorDefinitions)\</PreprocessorDefinitions\>  
      \<RuntimeLibrary\>MultiThreadedDLL\</RuntimeLibrary\>  
      \<FunctionLevelLinking\>true\</FunctionLevelLinking\>  
      \<IntrinsicFunctions\>true\</IntrinsicFunctions\>  
    \</ClCompile\>  
    \<Link\>  
      \<EnableCOMDATFolding\>true\</EnableCOMDATFolding\>  
      \<OptimizeReferences\>true\</OptimizeReferences\>  
    \</Link\>  
  \</ItemDefinitionGroup\>  
\</Project\>

### **ãƒ“ãƒ«ãƒ‰è¨­å®š**

#### **AthenaCore ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆ**

ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®ç¨®é¡: Static Library (.lib)

ã€å…¨èˆ¬ã€‘  
\- æ§‹æˆã®ç¨®é¡: ã‚¹ã‚¿ãƒ†ã‚£ãƒƒã‚¯ãƒ©ã‚¤ãƒ–ãƒ©ãƒª (.lib)  
\- C++è¨€èªæ¨™æº–: C++20  
\- Windows SDK ãƒãƒ¼ã‚¸ãƒ§ãƒ³: æœ€æ–°

ã€C/C++ â†’ ãƒ—ãƒªãƒ—ãƒ­ã‚»ãƒƒã‚µã€‘  
\- è¿½åŠ :  
  ATHENA\_CORE\_EXPORTS

ã€ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚¢ãƒ³ â†’ å…¨èˆ¬ã€‘  
\- å‡ºåŠ›ãƒ•ã‚¡ã‚¤ãƒ«: $(OutDir)$(TargetName)$(TargetExt)

ã€ãƒ“ãƒ«ãƒ‰ã‚¤ãƒ™ãƒ³ãƒˆ â†’ ãƒ“ãƒ«ãƒ‰å¾Œã€‘  
\- ã‚³ãƒãƒ³ãƒ‰ãƒ©ã‚¤ãƒ³:  
  xcopy /Y /D "$(ProjectDir)include\\\*" "$(OutDir)include\\" /S /I

#### **AthenaViewer ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆ**

ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®ç¨®é¡: Application (.exe)

ã€å…¨èˆ¬ã€‘  
\- æ§‹æˆã®ç¨®é¡: ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ (.exe)  
\- ã‚µãƒ–ã‚·ã‚¹ãƒ†ãƒ : Windows

ã€C/C++ã€‘  
\- è¿½åŠ ã®ã‚¤ãƒ³ã‚¯ãƒ«ãƒ¼ãƒ‰ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª:  
  $(SolutionDir)AthenaCore\\include;  
  %(AdditionalIncludeDirectories)

ã€ãƒªãƒ³ã‚«ãƒ¼ â†’ å…¥åŠ›ã€‘  
\- è¿½åŠ ã®ä¾å­˜ãƒ•ã‚¡ã‚¤ãƒ«:  
  AthenaCore.lib;  
  d3d12.lib;  
  dxgi.lib;  
  d3dcompiler.lib;  
  dxguid.lib;  
  %(AdditionalDependencies)

ã€ãƒªãƒ³ã‚«ãƒ¼ â†’ å…¨èˆ¬ã€‘  
\- è¿½åŠ ã®ãƒ©ã‚¤ãƒ–ãƒ©ãƒªãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª:  
  $(OutDir);  
  %(AdditionalLibraryDirectories)

ã€ãƒ“ãƒ«ãƒ‰ã‚¤ãƒ™ãƒ³ãƒˆ â†’ ãƒ“ãƒ«ãƒ‰å¾Œã€‘  
\- ã‚³ãƒãƒ³ãƒ‰ãƒ©ã‚¤ãƒ³:  
  xcopy /Y /D "$(SolutionDir)shaders\\\*.\*" "$(OutDir)shaders\\" /S /I  
  xcopy /Y /D "$(SolutionDir)configs\\\*.\*" "$(OutDir)configs\\" /S /I  
  xcopy /Y /D "$(SolutionDir)assets\\\*.\*" "$(OutDir)assets\\" /S /I

#### **Dear ImGuiã®ãƒ“ãƒ«ãƒ‰**

AthenaViewerãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã«ä»¥ä¸‹ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚’è¿½åŠ :

å¤–éƒ¨ãƒ©ã‚¤ãƒ–ãƒ©ãƒª (ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ä½œæˆ)  
â”œâ”€ imgui/  
   â”œâ”€ imgui.cpp  
   â”œâ”€ imgui\_demo.cpp  
   â”œâ”€ imgui\_draw.cpp  
   â”œâ”€ imgui\_tables.cpp  
   â”œâ”€ imgui\_widgets.cpp  
   â””â”€ backends/  
      â”œâ”€ imgui\_impl\_win32.cpp  
      â””â”€ imgui\_impl\_dx12.cpp

---

## **ã‚³ã‚¢å®Ÿè£…**

### **1\. Device (ãƒ‡ãƒã‚¤ã‚¹ç®¡ç†)**

**include/Athena/Core/Device.h**

\#pragma once  
\#include \<d3d12.h\>  
\#include \<dxgi1\_6.h\>  
\#include \<wrl/client.h\>

namespace Athena {

using Microsoft::WRL::ComPtr;

class Device {  
public:  
    Device();  
    \~Device();  
      
    // åˆæœŸåŒ–ãƒ»çµ‚äº†  
    void Initialize(bool enableDebugLayer \= true);  
    void Shutdown();  
      
    // ã‚¢ã‚¯ã‚»ã‚µ  
    ID3D12Device5\* GetD3D12Device() const { return device.Get(); }  
    IDXGIFactory6\* GetDXGIFactory() const { return factory.Get(); }  
    IDXGIAdapter4\* GetAdapter() const { return adapter.Get(); }  
      
    // æ©Ÿèƒ½ã‚µãƒãƒ¼ãƒˆç¢ºèª  
    bool SupportsMeshShaders() const { return supportMeshShaders; }  
    bool SupportsRaytracing() const { return supportRaytracing; }  
    bool SupportsVariableRateShading() const { return supportVRS; }  
      
private:  
    ComPtr\<ID3D12Device5\> device;  
    ComPtr\<IDXGIFactory6\> factory;  
    ComPtr\<IDXGIAdapter4\> adapter;  
      
    bool supportMeshShaders \= false;  
    bool supportRaytracing \= false;  
    bool supportVRS \= false;  
      
    void EnableDebugLayer();  
    void SelectBestAdapter();  
    void CheckFeatureSupport();  
};

} // namespace Athena

**src/Athena/Core/Device.cpp**

\#include "Athena/Core/Device.h"  
\#include "Athena/Utils/Logger.h"  
\#include \<stdexcept\>

namespace Athena {

Device::Device() \= default;  
Device::\~Device() \= default;

void Device::Initialize(bool enableDebugLayer) {  
    Logger::Info("Initializing Device...");  
      
    if (enableDebugLayer) {  
        EnableDebugLayer();  
    }  
      
    // DXGIãƒ•ã‚¡ã‚¯ãƒˆãƒªä½œæˆ  
    UINT flags \= 0;  
    if (enableDebugLayer) {  
        flags \= DXGI\_CREATE\_FACTORY\_DEBUG;  
    }  
      
    HRESULT hr \= CreateDXGIFactory2(flags, IID\_PPV\_ARGS(\&factory));  
    if (FAILED(hr)) {  
        throw std::runtime\_error("Failed to create DXGI factory");  
    }  
      
    // æœ€é©ãªã‚¢ãƒ€ãƒ—ã‚¿ãƒ¼é¸æŠ  
    SelectBestAdapter();  
      
    // ãƒ‡ãƒã‚¤ã‚¹ä½œæˆ  
    hr \= D3D12CreateDevice(  
        adapter.Get(),  
        D3D\_FEATURE\_LEVEL\_12\_0,  
        IID\_PPV\_ARGS(\&device)  
    );  
      
    if (FAILED(hr)) {  
        throw std::runtime\_error("Failed to create D3D12 device");  
    }  
      
    // æ©Ÿèƒ½ã‚µãƒãƒ¼ãƒˆãƒã‚§ãƒƒã‚¯  
    CheckFeatureSupport();  
      
    Logger::Info("Device initialized successfully");  
}

void Device::Shutdown() {  
    Logger::Info("Shutting down Device...");  
      
    device.Reset();  
    adapter.Reset();  
    factory.Reset();  
}

void Device::EnableDebugLayer() {  
\#ifdef \_DEBUG  
    ComPtr\<ID3D12Debug\> debugController;  
    if (SUCCEEDED(D3D12GetDebugInterface(IID\_PPV\_ARGS(\&debugController)))) {  
        debugController-\>EnableDebugLayer();  
        Logger::Info("D3D12 Debug Layer enabled");  
    }  
\#endif  
}

void Device::SelectBestAdapter() {  
    ComPtr\<IDXGIAdapter1\> tempAdapter;  
    SIZE\_T maxVideoMemory \= 0;  
      
    for (UINT i \= 0;   
         factory-\>EnumAdapters1(i, \&tempAdapter) \!= DXGI\_ERROR\_NOT\_FOUND;   
         \++i) {  
          
        DXGI\_ADAPTER\_DESC1 desc;  
        tempAdapter-\>GetDesc1(\&desc);  
          
        // ã‚½ãƒ•ãƒˆã‚¦ã‚§ã‚¢ã‚¢ãƒ€ãƒ—ã‚¿ãƒ¼ã‚’ã‚¹ã‚­ãƒƒãƒ—  
        if (desc.Flags & DXGI\_ADAPTER\_FLAG\_SOFTWARE) {  
            continue;  
        }  
          
        // D3D12å¯¾å¿œãƒã‚§ãƒƒã‚¯  
        if (SUCCEEDED(D3D12CreateDevice(  
            tempAdapter.Get(),  
            D3D\_FEATURE\_LEVEL\_12\_0,  
            \_\_uuidof(ID3D12Device), nullptr))) {  
              
            // æœ€å¤§VRAMã®ã‚¢ãƒ€ãƒ—ã‚¿ãƒ¼ã‚’é¸æŠ  
            if (desc.DedicatedVideoMemory \> maxVideoMemory) {  
                maxVideoMemory \= desc.DedicatedVideoMemory;  
                tempAdapter.As(\&adapter);  
            }  
        }  
    }  
      
    if (\!adapter) {  
        throw std::runtime\_error("No compatible adapter found");  
    }  
      
    DXGI\_ADAPTER\_DESC1 desc;  
    adapter-\>GetDesc1(\&desc);  
    Logger::Info("Selected GPU: %S", desc.Description);  
    Logger::Info("VRAM: %.2f GB", desc.DedicatedVideoMemory / (1024.0 \* 1024.0 \* 1024.0));  
}

void Device::CheckFeatureSupport() {  
    // Mesh Shaderå¯¾å¿œ  
    D3D12\_FEATURE\_DATA\_D3D12\_OPTIONS7 options7 \= {};  
    if (SUCCEEDED(device-\>CheckFeatureSupport(  
        D3D12\_FEATURE\_D3D12\_OPTIONS7,  
        \&options7, sizeof(options7)))) {  
        supportMeshShaders \= (options7.MeshShaderTier \>= D3D12\_MESH\_SHADER\_TIER\_1);  
    }  
      
    // Raytracingå¯¾å¿œ  
    D3D12\_FEATURE\_DATA\_D3D12\_OPTIONS5 options5 \= {};  
    if (SUCCEEDED(device-\>CheckFeatureSupport(  
        D3D12\_FEATURE\_D3D12\_OPTIONS5,  
        \&options5, sizeof(options5)))) {  
        supportRaytracing \= (options5.RaytracingTier \>= D3D12\_RAYTRACING\_TIER\_1\_0);  
    }  
      
    // VRSå¯¾å¿œ  
    D3D12\_FEATURE\_DATA\_D3D12\_OPTIONS6 options6 \= {};  
    if (SUCCEEDED(device-\>CheckFeatureSupport(  
        D3D12\_FEATURE\_D3D12\_OPTIONS6,  
        \&options6, sizeof(options6)))) {  
        supportVRS \= (options6.VariableShadingRateTier \>= D3D12\_VARIABLE\_SHADING\_RATE\_TIER\_1);  
    }  
      
    Logger::Info("Feature Support:");  
    Logger::Info("  Mesh Shaders: %s", supportMeshShaders ? "Yes" : "No");  
    Logger::Info("  Raytracing: %s", supportRaytracing ? "Yes" : "No");  
    Logger::Info("  VRS: %s", supportVRS ? "Yes" : "No");  
}

} // namespace Athena

### **2\. CommandQueue (ã‚³ãƒãƒ³ãƒ‰ã‚­ãƒ¥ãƒ¼)**

**include/Athena/Core/CommandQueue.h**

\#pragma once  
\#include \<d3d12.h\>  
\#include \<wrl/client.h\>  
\#include \<cstdint\>

namespace Athena {

using Microsoft::WRL::ComPtr;

class CommandQueue {  
public:  
    CommandQueue();  
    \~CommandQueue();  
      
    void Initialize(ID3D12Device\* device, D3D12\_COMMAND\_LIST\_TYPE type);  
    void Shutdown();  
      
    // ã‚³ãƒãƒ³ãƒ‰å®Ÿè¡Œ  
    void ExecuteCommandLists(ID3D12CommandList\* const\* commandLists, uint32\_t count);  
      
    // åŒæœŸ  
    void WaitForGPU();  
    void Signal();  
    uint64\_t GetCompletedValue() const;  
      
    // ã‚¢ã‚¯ã‚»ã‚µ  
    ID3D12CommandQueue\* GetD3D12CommandQueue() const { return queue.Get(); }  
      
private:  
    ComPtr\<ID3D12CommandQueue\> queue;  
    ComPtr\<ID3D12Fence\> fence;  
    HANDLE fenceEvent \= nullptr;  
    uint64\_t fenceValue \= 0;  
};

} // namespace Athena

**src/Athena/Core/CommandQueue.cpp**

\#include "Athena/Core/CommandQueue.h"  
\#include "Athena/Utils/Logger.h"  
\#include \<stdexcept\>

namespace Athena {

CommandQueue::CommandQueue() \= default;

CommandQueue::\~CommandQueue() {  
    if (fenceEvent) {  
        CloseHandle(fenceEvent);  
    }  
}

void CommandQueue::Initialize(ID3D12Device\* device, D3D12\_COMMAND\_LIST\_TYPE type) {  
    // ã‚³ãƒãƒ³ãƒ‰ã‚­ãƒ¥ãƒ¼ä½œæˆ  
    D3D12\_COMMAND\_QUEUE\_DESC queueDesc \= {};  
    queueDesc.Type \= type;  
    queueDesc.Priority \= D3D12\_COMMAND\_QUEUE\_PRIORITY\_NORMAL;  
    queueDesc.Flags \= D3D12\_COMMAND\_QUEUE\_FLAG\_NONE;  
    queueDesc.NodeMask \= 0;  
      
    HRESULT hr \= device-\>CreateCommandQueue(\&queueDesc, IID\_PPV\_ARGS(\&queue));  
    if (FAILED(hr)) {  
        throw std::runtime\_error("Failed to create command queue");  
    }  
      
    // ãƒ•ã‚§ãƒ³ã‚¹ä½œæˆ  
    hr \= device-\>CreateFence(0, D3D12\_FENCE\_FLAG\_NONE, IID\_PPV\_ARGS(\&fence));  
    if (FAILED(hr)) {  
        throw std::runtime\_error("Failed to create fence");  
    }  
      
    // ã‚¤ãƒ™ãƒ³ãƒˆä½œæˆ  
    fenceEvent \= CreateEvent(nullptr, FALSE, FALSE, nullptr);  
    if (\!fenceEvent) {  
        throw std::runtime\_error("Failed to create fence event");  
    }  
      
    Logger::Info("CommandQueue initialized");  
}

void CommandQueue::Shutdown() {  
    WaitForGPU();  
      
    if (fenceEvent) {  
        CloseHandle(fenceEvent);  
        fenceEvent \= nullptr;  
    }  
      
    fence.Reset();  
    queue.Reset();  
}

void CommandQueue::ExecuteCommandLists(ID3D12CommandList\* const\* commandLists, uint32\_t count) {  
    queue-\>ExecuteCommandLists(count, commandLists);  
}

void CommandQueue::Signal() {  
    \++fenceValue;  
    queue-\>Signal(fence.Get(), fenceValue);  
}

void CommandQueue::WaitForGPU() {  
    Signal();  
      
    if (fence-\>GetCompletedValue() \< fenceValue) {  
        fence-\>SetEventOnCompletion(fenceValue, fenceEvent);  
        WaitForSingleObject(fenceEvent, INFINITE);  
    }  
}

uint64\_t CommandQueue::GetCompletedValue() const {  
    return fence-\>GetCompletedValue();  
}

} // namespace Athena

### **3\. SwapChain (ã‚¹ãƒ¯ãƒƒãƒ—ãƒã‚§ãƒ¼ãƒ³)**

**include/Athena/Core/SwapChain.h**

\#pragma once  
\#include \<d3d12.h\>  
\#include \<dxgi1\_6.h\>  
\#include \<wrl/client.h\>  
\#include \<cstdint\>  
\#include \<vector\>

namespace Athena {

using Microsoft::WRL::ComPtr;

class SwapChain {  
public:  
    static constexpr uint32\_t BufferCount \= 3; // ãƒˆãƒªãƒ—ãƒ«ãƒãƒƒãƒ•ã‚¡  
      
    SwapChain();  
    \~SwapChain();  
      
    void Initialize(  
        IDXGIFactory6\* factory,  
        ID3D12CommandQueue\* commandQueue,  
        HWND hwnd,  
        uint32\_t width,  
        uint32\_t height  
    );  
      
    void Shutdown();  
      
    // ãƒãƒƒãƒ•ã‚¡æ“ä½œ  
    void Present(bool vsync \= true);  
    uint32\_t GetCurrentBackBufferIndex() const;  
    ID3D12Resource\* GetCurrentBackBuffer() const;  
    ID3D12Resource\* GetBackBuffer(uint32\_t index) const;  
      
    // ãƒªã‚µã‚¤ã‚º  
    void Resize(uint32\_t width, uint32\_t height);  
      
    // ã‚¢ã‚¯ã‚»ã‚µ  
    IDXGISwapChain4\* GetDXGISwapChain() const { return swapChain.Get(); }  
    uint32\_t GetWidth() const { return width; }  
    uint32\_t GetHeight() const { return height; }  
    DXGI\_FORMAT GetFormat() const { return format; }  
      
private:  
    ComPtr\<IDXGISwapChain4\> swapChain;  
    std::vector\<ComPtr\<ID3D12Resource\>\> backBuffers;  
      
    uint32\_t width \= 0;  
    uint32\_t height \= 0;  
    DXGI\_FORMAT format \= DXGI\_FORMAT\_R8G8B8A8\_UNORM;  
      
    void CreateBackBuffers();  
};

} // namespace Athena

**src/Athena/Core/SwapChain.cpp**

\#include "Athena/Core/SwapChain.h"  
\#include "Athena/Utils/Logger.h"  
\#include \<stdexcept\>

namespace Athena {

SwapChain::SwapChain() \= default;  
SwapChain::\~SwapChain() \= default;

void SwapChain::Initialize(  
    IDXGIFactory6\* factory,  
    ID3D12CommandQueue\* commandQueue,  
    HWND hwnd,  
    uint32\_t width,  
    uint32\_t height) {  
      
    this-\>width \= width;  
    this-\>height \= height;  
      
    // ã‚¹ãƒ¯ãƒƒãƒ—ãƒã‚§ãƒ¼ãƒ³ä½œæˆ  
    DXGI\_SWAP\_CHAIN\_DESC1 swapChainDesc \= {};  
    swapChainDesc.Width \= width;  
    swapChainDesc.Height \= height;  
    swapChainDesc.Format \= format;  
    swapChainDesc.Stereo \= FALSE;  
    swapChainDesc.SampleDesc.Count \= 1;  
    swapChainDesc.SampleDesc.Quality \= 0;  
    swapChainDesc.BufferUsage \= DXGI\_USAGE\_RENDER\_TARGET\_OUTPUT;  
    swapChainDesc.BufferCount \= BufferCount;  
    swapChainDesc.Scaling \= DXGI\_SCALING\_STRETCH;  
    swapChainDesc.SwapEffect \= DXGI\_SWAP\_EFFECT\_FLIP\_DISCARD;  
    swapChainDesc.AlphaMode \= DXGI\_ALPHA\_MODE\_UNSPECIFIED;  
    swapChainDesc.Flags \= DXGI\_SWAP\_CHAIN\_FLAG\_ALLOW\_TEARING;  
      
    ComPtr\<IDXGISwapChain1\> swapChain1;  
    HRESULT hr \= factory-\>CreateSwapChainForHwnd(  
        commandQueue,  
        hwnd,  
        \&swapChainDesc,  
        nullptr,  
        nullptr,  
        \&swapChain1  
    );  
      
    if (FAILED(hr)) {  
        throw std::runtime\_error("Failed to create swap chain");  
    }  
      
    // IDXGISwapChain4ã«ã‚­ãƒ£ã‚¹ãƒˆ  
    swapChain1.As(\&swapChain);  
      
    // Alt+Enterã®ç„¡åŠ¹åŒ–  
    factory-\>MakeWindowAssociation(hwnd, DXGI\_MWA\_NO\_ALT\_ENTER);  
      
    // ãƒãƒƒã‚¯ãƒãƒƒãƒ•ã‚¡ä½œæˆ  
    CreateBackBuffers();  
      
    Logger::Info("SwapChain initialized (%ux%u)", width, height);  
}

void SwapChain::Shutdown() {  
    backBuffers.clear();  
    swapChain.Reset();  
}

void SwapChain::Present(bool vsync) {  
    UINT syncInterval \= vsync ? 1 : 0;  
    UINT flags \= vsync ? 0 : DXGI\_PRESENT\_ALLOW\_TEARING;  
      
    swapChain-\>Present(syncInterval, flags);  
}

uint32\_t SwapChain::GetCurrentBackBufferIndex() const {  
    return swapChain-\>GetCurrentBackBufferIndex();  
}

ID3D12Resource\* SwapChain::GetCurrentBackBuffer() const {  
    return backBuffers\[GetCurrentBackBufferIndex()\].Get();  
}

ID3D12Resource\* SwapChain::GetBackBuffer(uint32\_t index) const {  
    return backBuffers\[index\].Get();  
}

void SwapChain::Resize(uint32\_t width, uint32\_t height) {  
    if (this-\>width \== width && this-\>height \== height) {  
        return;  
    }  
      
    this-\>width \= width;  
    this-\>height \= height;  
      
    // ãƒãƒƒã‚¯ãƒãƒƒãƒ•ã‚¡è§£æ”¾  
    backBuffers.clear();  
      
    // ãƒªã‚µã‚¤ã‚º  
    HRESULT hr \= swapChain-\>ResizeBuffers(  
        BufferCount,  
        width,  
        height,  
        format,  
        DXGI\_SWAP\_CHAIN\_FLAG\_ALLOW\_TEARING  
    );  
      
    if (FAILED(hr)) {  
        throw std::runtime\_error("Failed to resize swap chain");  
    }  
      
    // ãƒãƒƒã‚¯ãƒãƒƒãƒ•ã‚¡å†ä½œæˆ  
    CreateBackBuffers();  
      
    Logger::Info("SwapChain resized to %ux%u", width, height);  
}

void SwapChain::CreateBackBuffers() {  
    backBuffers.resize(BufferCount);  
      
    for (uint32\_t i \= 0; i \< BufferCount; \++i) {  
        HRESULT hr \= swapChain-\>GetBuffer(i, IID\_PPV\_ARGS(\&backBuffers\[i\]));  
        if (FAILED(hr)) {  
            throw std::runtime\_error("Failed to get back buffer");  
        }  
    }  
}

} // namespace Athena

### **4\. DescriptorHeap (ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ’ãƒ¼ãƒ—)**

**include/Athena/Core/DescriptorHeap.h**

\#pragma once  
\#include \<d3d12.h\>  
\#include \<wrl/client.h\>  
\#include \<cstdint\>  
\#include \<vector\>

namespace Athena {

using Microsoft::WRL::ComPtr;

struct DescriptorHandle {  
    D3D12\_CPU\_DESCRIPTOR\_HANDLE cpu;  
    D3D12\_GPU\_DESCRIPTOR\_HANDLE gpu;  
    uint32\_t index \= 0;  
      
    bool IsValid() const { return cpu.ptr \!= 0; }  
    bool IsShaderVisible() const { return gpu.ptr \!= 0; }  
};

class DescriptorHeap {  
public:  
    DescriptorHeap();  
    \~DescriptorHeap();  
      
    void Initialize(  
        ID3D12Device\* device,  
        D3D12\_DESCRIPTOR\_HEAP\_TYPE type,  
        uint32\_t capacity,  
        bool shaderVisible \= false  
    );  
      
    void Shutdown();  
      
    // ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿å‰²ã‚Šå½“ã¦  
    DescriptorHandle Allocate();  
    void Free(const DescriptorHandle& handle);  
      
    // ã‚¢ã‚¯ã‚»ã‚µ  
    ID3D12DescriptorHeap\* GetD3D12DescriptorHeap() const { return heap.Get(); }  
    uint32\_t GetDescriptorSize() const { return descriptorSize; }  
      
private:  
    ComPtr\<ID3D12DescriptorHeap\> heap;  
    D3D12\_DESCRIPTOR\_HEAP\_TYPE type;  
    uint32\_t capacity \= 0;  
    uint32\_t descriptorSize \= 0;  
    bool shaderVisible \= false;  
      
    D3D12\_CPU\_DESCRIPTOR\_HANDLE cpuStart \= {};  
    D3D12\_GPU\_DESCRIPTOR\_HANDLE gpuStart \= {};  
      
    std::vector\<bool\> allocated;  
    uint32\_t nextFreeIndex \= 0;  
};

} // namespace Athena

**src/Athena/Core/DescriptorHeap.cpp**

\#include "Athena/Core/DescriptorHeap.h"  
\#include "Athena/Utils/Logger.h"  
\#include \<stdexcept\>

namespace Athena {

DescriptorHeap::DescriptorHeap() \= default;  
DescriptorHeap::\~DescriptorHeap() \= default;

void DescriptorHeap::Initialize(  
    ID3D12Device\* device,  
    D3D12\_DESCRIPTOR\_HEAP\_TYPE type,  
    uint32\_t capacity,  
    bool shaderVisible) {  
      
    this-\>type \= type;  
    this-\>capacity \= capacity;  
    this-\>shaderVisible \= shaderVisible;  
      
    // ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ’ãƒ¼ãƒ—ä½œæˆ  
    D3D12\_DESCRIPTOR\_HEAP\_DESC heapDesc \= {};  
    heapDesc.Type \= type;  
    heapDesc.NumDescriptors \= capacity;  
    heapDesc.Flags \= shaderVisible ?   
        D3D12\_DESCRIPTOR\_HEAP\_FLAG\_SHADER\_VISIBLE :   
        D3D12\_DESCRIPTOR\_HEAP\_FLAG\_NONE;  
    heapDesc.NodeMask \= 0;  
      
    HRESULT hr \= device-\>CreateDescriptorHeap(\&heapDesc, IID\_PPV\_ARGS(\&heap));  
    if (FAILED(hr)) {  
        throw std::runtime\_error("Failed to create descriptor heap");  
    }  
      
    // ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã‚µã‚¤ã‚ºå–å¾—  
    descriptorSize \= device-\>GetDescriptorHandleIncrementSize(type);  
      
    // ãƒãƒ³ãƒ‰ãƒ«å–å¾—  
    cpuStart \= heap-\>GetCPUDescriptorHandleForHeapStart();  
    if (shaderVisible) {  
        gpuStart \= heap-\>GetGPUDescriptorHandleForHeapStart();  
    }  
      
    // å‰²ã‚Šå½“ã¦ç®¡ç†åˆæœŸåŒ–  
    allocated.resize(capacity, false);  
      
    Logger::Info("DescriptorHeap initialized (capacity: %u)", capacity);  
}

void DescriptorHeap::Shutdown() {  
    allocated.clear();  
    heap.Reset();  
}

DescriptorHandle DescriptorHeap::Allocate() {  
    // ãƒ•ãƒªãƒ¼ãªã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’æ¤œç´¢  
    for (uint32\_t i \= nextFreeIndex; i \< capacity; \++i) {  
        if (\!allocated\[i\]) {  
            allocated\[i\] \= true;  
            nextFreeIndex \= i \+ 1;  
              
            DescriptorHandle handle;  
            handle.index \= i;  
            handle.cpu.ptr \= cpuStart.ptr \+ i \* descriptorSize;  
            if (shaderVisible) {  
                handle.gpu.ptr \= gpuStart.ptr \+ i \* descriptorSize;  
            }  
              
            return handle;  
        }  
    }  
      
    throw std::runtime\_error("Descriptor heap is full");  
}

void DescriptorHeap::Free(const DescriptorHandle& handle) {  
    if (handle.index \< capacity) {  
        allocated\[handle.index\] \= false;  
        if (handle.index \< nextFreeIndex) {  
            nextFreeIndex \= handle.index;  
        }  
    }  
}

} // namespace Athena

---

## **ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚°ãƒ©ãƒ•ã‚·ã‚¹ãƒ†ãƒ **

### **RenderPass (ãƒ¬ãƒ³ãƒ€ãƒ¼ãƒ‘ã‚¹åŸºåº•ã‚¯ãƒ©ã‚¹)**

**include/Athena/RenderGraph/RenderPass.h**

\#pragma once  
\#include \<string\>  
\#include \<vector\>

namespace Athena {

class RenderGraphBuilder;  
class RenderContext;

class RenderPass {  
public:  
    virtual \~RenderPass() \= default;  
      
    // ãƒ‘ã‚¹ã®ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—(ãƒªã‚½ãƒ¼ã‚¹å®£è¨€)  
    virtual void Setup(RenderGraphBuilder& builder) \= 0;  
      
    // å®Ÿè¡Œ  
    virtual void Execute(RenderContext& context) \= 0;  
      
    // å…¥åŠ›ãƒªã‚½ãƒ¼ã‚¹å®£è¨€  
    virtual std::vector\<std::string\> GetInputs() const { return {}; }  
      
    // å‡ºåŠ›ãƒªã‚½ãƒ¼ã‚¹å®£è¨€  
    virtual std::vector\<std::string\> GetOutputs() const { return {}; }  
      
    // ãƒ‘ã‚¹å  
    virtual const char\* GetName() const \= 0;  
      
    // æœ‰åŠ¹/ç„¡åŠ¹  
    void SetEnabled(bool enabled) { isEnabled \= enabled; }  
    bool IsEnabled() const { return isEnabled; }  
      
    // å®Ÿè¡Œæ™‚é–“å–å¾—  
    float GetLastExecutionTime() const { return lastExecutionTime; }  
      
protected:  
    bool isEnabled \= true;  
    float lastExecutionTime \= 0.0f;  
};

} // namespace Athena

### **RenderGraph (ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚°ãƒ©ãƒ•æœ¬ä½“)**

**include/Athena/RenderGraph/RenderGraph.h**

\#pragma once  
\#include "Athena/RenderGraph/RenderPass.h"  
\#include "Athena/RenderGraph/ResourceHandle.h"  
\#include \<memory\>  
\#include \<vector\>  
\#include \<unordered\_map\>  
\#include \<string\>

namespace Athena {

class RenderContext;

class RenderGraph {  
public:  
    RenderGraph();  
    \~RenderGraph();  
      
    // ãƒ‘ã‚¹è¿½åŠ   
    template\<typename PassType, typename... Args\>  
    PassType\* AddPass(Args&&... args) {  
        auto pass \= std::make\_unique\<PassType\>(std::forward\<Args\>(args)...);  
        PassType\* ptr \= pass.get();  
        passes.push\_back(std::move(pass));  
        return ptr;  
    }  
      
    // å‹•çš„ãƒ‘ã‚¹è¿½åŠ   
    void AddPassDynamic(std::unique\_ptr\<RenderPass\> pass);  
      
    // ã‚°ãƒ©ãƒ•ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«  
    void Compile();  
      
    // å®Ÿè¡Œ  
    void Execute(RenderContext& context);  
      
    // ãƒªã‚½ãƒ¼ã‚¹å–å¾—  
    ResourceHandle GetResource(const std::string& name);  
      
    // ãƒ‘ã‚¹å–å¾—  
    const std::vector\<std::unique\_ptr\<RenderPass\>\>& GetPasses() const { return passes; }  
    size\_t GetPassCount() const { return passes.size(); }  
      
    // ã‚°ãƒ©ãƒ•ã‚¯ãƒªã‚¢  
    void Clear();  
      
private:  
    std::vector\<std::unique\_ptr\<RenderPass\>\> passes;  
    std::unordered\_map\<std::string, ResourceHandle\> resources;  
    bool compiled \= false;  
      
    // ä¾å­˜é–¢ä¿‚è§£æ±º  
    void ResolveDependencies();  
      
    // ãƒªã‚½ãƒ¼ã‚¹ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ è§£æ  
    void AnalyzeResourceLifetime();  
      
    // ãƒ¡ãƒ¢ãƒªæœ€é©åŒ–  
    void OptimizeResourceAllocation();  
      
    // ãƒˆãƒãƒ­ã‚¸ã‚«ãƒ«ã‚½ãƒ¼ãƒˆ  
    void TopologicalSort();  
};

} // namespace Athena

**src/Athena/RenderGraph/RenderGraph.cpp**

\#include "Athena/RenderGraph/RenderGraph.h"  
\#include "Athena/Utils/Logger.h"  
\#include \<algorithm\>  
\#include \<unordered\_set\>

namespace Athena {

RenderGraph::RenderGraph() \= default;  
RenderGraph::\~RenderGraph() \= default;

void RenderGraph::AddPassDynamic(std::unique\_ptr\<RenderPass\> pass) {  
    passes.push\_back(std::move(pass));  
}

void RenderGraph::Compile() {  
    Logger::Info("Compiling RenderGraph...");  
      
    // 1\. ä¾å­˜é–¢ä¿‚è§£æ±º  
    ResolveDependencies();  
      
    // 2\. ãƒˆãƒãƒ­ã‚¸ã‚«ãƒ«ã‚½ãƒ¼ãƒˆ  
    TopologicalSort();  
      
    // 3\. ãƒªã‚½ãƒ¼ã‚¹ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ è§£æ  
    AnalyzeResourceLifetime();  
      
    // 4\. ãƒ¡ãƒ¢ãƒªæœ€é©åŒ–  
    OptimizeResourceAllocation();  
      
    compiled \= true;  
    Logger::Info("RenderGraph compiled successfully (%zu passes)", passes.size());  
}

void RenderGraph::Execute(RenderContext& context) {  
    if (\!compiled) {  
        Logger::Warning("RenderGraph not compiled, compiling now...");  
        Compile();  
    }  
      
    for (auto& pass : passes) {  
        if (pass-\>IsEnabled()) {  
            // TODO: ã‚¿ã‚¤ãƒãƒ¼ã§å®Ÿè¡Œæ™‚é–“è¨ˆæ¸¬  
            pass-\>Execute(context);  
        }  
    }  
}

ResourceHandle RenderGraph::GetResource(const std::string& name) {  
    auto it \= resources.find(name);  
    if (it \!= resources.end()) {  
        return it-\>second;  
    }  
    return ResourceHandle();  
}

void RenderGraph::Clear() {  
    passes.clear();  
    resources.clear();  
    compiled \= false;  
}

void RenderGraph::ResolveDependencies() {  
    // å„ãƒ‘ã‚¹ã®å…¥å‡ºåŠ›ã‚’è§£æ  
    std::unordered\_map\<std::string, std::vector\<RenderPass\*\>\> producers;  
    std::unordered\_map\<std::string, std::vector\<RenderPass\*\>\> consumers;  
      
    for (auto& pass : passes) {  
        // å‡ºåŠ›ãƒªã‚½ãƒ¼ã‚¹ã®ç™»éŒ²  
        for (const auto& output : pass-\>GetOutputs()) {  
            producers\[output\].push\_back(pass.get());  
        }  
          
        // å…¥åŠ›ãƒªã‚½ãƒ¼ã‚¹ã®ç™»éŒ²  
        for (const auto& input : pass-\>GetInputs()) {  
            consumers\[input\].push\_back(pass.get());  
        }  
    }  
      
    // ä¾å­˜é–¢ä¿‚ã®æ¤œè¨¼  
    for (const auto& \[resource, consumerList\] : consumers) {  
        if (producers.find(resource) \== producers.end()) {  
            Logger::Warning("Resource '%s' has no producer", resource.c\_str());  
        }  
    }  
}

void RenderGraph::AnalyzeResourceLifetime() {  
    // ãƒªã‚½ãƒ¼ã‚¹ã®æœ€åˆã®ä½¿ç”¨ã¨æœ€å¾Œã®ä½¿ç”¨ã‚’ç‰¹å®š  
    // ã“ã‚Œã«ã‚ˆã‚Šã€ãƒªã‚½ãƒ¼ã‚¹ã®ã‚¨ã‚¤ãƒªã‚¢ã‚·ãƒ³ã‚°ãŒå¯èƒ½ã«  
    // TODO: å®Ÿè£…  
}

void RenderGraph::OptimizeResourceAllocation() {  
    // ãƒ¡ãƒ¢ãƒªã‚¨ã‚¤ãƒªã‚¢ã‚·ãƒ³ã‚°  
    // ä½¿ç”¨æœŸé–“ãŒé‡ãªã‚‰ãªã„ãƒªã‚½ãƒ¼ã‚¹ã¯åŒã˜ãƒ¡ãƒ¢ãƒªã‚’å…±æœ‰å¯èƒ½  
    // TODO: å®Ÿè£…  
}

void RenderGraph::TopologicalSort() {  
    // ä¾å­˜é–¢ä¿‚ã«åŸºã¥ã„ã¦ãƒ‘ã‚¹ã‚’ã‚½ãƒ¼ãƒˆ  
    // ç¾åœ¨ã¯å˜ç´”ãªé †åºã‚’ç¶­æŒ(å¾Œã§æ”¹å–„)  
    // TODO: æœ¬æ ¼çš„ãªãƒˆãƒãƒ­ã‚¸ã‚«ãƒ«ã‚½ãƒ¼ãƒˆå®Ÿè£…  
}

} // namespace Athena

### **PassRegistry (ãƒ‘ã‚¹ç™»éŒ²)**

**include/Athena/RenderGraph/PassRegistry.h**

\#pragma once  
\#include "Athena/RenderGraph/RenderPass.h"  
\#include \<memory\>  
\#include \<string\>  
\#include \<unordered\_map\>  
\#include \<functional\>

namespace Athena {

class PassRegistry {  
public:  
    using CreateFunc \= std::function\<std::unique\_ptr\<RenderPass\>()\>;  
      
    static void Register(const std::string& name, CreateFunc func);  
    static std::unique\_ptr\<RenderPass\> Create(const std::string& name);  
    static PassRegistry& GetInstance();  
      
private:  
    std::unordered\_map\<std::string, CreateFunc\> registry;  
};

// ãƒ‘ã‚¹ç™»éŒ²ãƒã‚¯ãƒ­  
\#define ATHENA\_REGISTER\_PASS(PassClass) \\  
    namespace { \\  
        struct PassClass\#\#Registrar { \\  
            PassClass\#\#Registrar() { \\  
                PassRegistry::Register(\#PassClass, \[\]() { \\  
                    return std::make\_unique\<PassClass\>(); \\  
                }); \\  
            } \\  
        }; \\  
        static PassClass\#\#Registrar g\_\#\#PassClass\#\#Registrar; \\  
    }

} // namespace Athena

**src/Athena/RenderGraph/PassRegistry.cpp**

\#include "Athena/RenderGraph/PassRegistry.h"  
\#include "Athena/Utils/Logger.h"

namespace Athena {

PassRegistry& PassRegistry::GetInstance() {  
    static PassRegistry instance;  
    return instance;  
}

void PassRegistry::Register(const std::string& name, CreateFunc func) {  
    auto& instance \= GetInstance();  
    instance.registry\[name\] \= func;  
    Logger::Info("Registered pass: %s", name.c\_str());  
}

std::unique\_ptr\<RenderPass\> PassRegistry::Create(const std::string& name) {  
    auto& instance \= GetInstance();  
    auto it \= instance.registry.find(name);  
    if (it \!= instance.registry.end()) {  
        return it-\>second();  
    }  
    Logger::Error("Pass '%s' not found in registry", name.c\_str());  
    return nullptr;  
}

} // namespace Athena

---

## **æ¨™æº–ãƒ¬ãƒ³ãƒ€ãƒ¼ãƒ‘ã‚¹**

### **GeometryPass**

**AthenaViewer/Passes/GeometryPass.h**

\#pragma once  
\#include \<Athena/RenderGraph/RenderPass.h\>

namespace Athena {

class Scene;

class GeometryPass : public RenderPass {  
public:  
    GeometryPass(Scene\* scene);  
      
    void Setup(RenderGraphBuilder& builder) override;  
    void Execute(RenderContext& context) override;  
      
    std::vector\<std::string\> GetOutputs() const override;  
    const char\* GetName() const override { return "GeometryPass"; }  
      
private:  
    Scene\* scene;  
};

} // namespace Athena

**AthenaViewer/Passes/GeometryPass.cpp**

\#include "GeometryPass.h"  
\#include \<Athena/Scene/Scene.h\>  
\#include \<Athena/Rendering/RenderContext.h\>

namespace Athena {

GeometryPass::GeometryPass(Scene\* scene) : scene(scene) {}

void GeometryPass::Setup(RenderGraphBuilder& builder) {  
    // TODO: ãƒªã‚½ãƒ¼ã‚¹å®£è¨€  
}

void GeometryPass::Execute(RenderContext& context) {  
    // TODO: ã‚¸ã‚ªãƒ¡ãƒˆãƒªãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°  
}

std::vector\<std::string\> GeometryPass::GetOutputs() const {  
    return {"GBuffer\_Albedo", "GBuffer\_Normal", "GBuffer\_Depth"};  
}

ATHENA\_REGISTER\_PASS(GeometryPass);

} // namespace Athena

### **LightingPass**

**AthenaViewer/Passes/LightingPass.h**

\#pragma once  
\#include \<Athena/RenderGraph/RenderPass.h\>

namespace Athena {

class LightingPass : public RenderPass {  
public:  
    void Setup(RenderGraphBuilder& builder) override;  
    void Execute(RenderContext& context) override;  
      
    std::vector\<std::string\> GetInputs() const override;  
    std::vector\<std::string\> GetOutputs() const override;  
    const char\* GetName() const override { return "LightingPass"; }  
};

} // namespace Athena

**AthenaViewer/Passes/LightingPass.cpp**

\#include "LightingPass.h"  
\#include \<Athena/Rendering/RenderContext.h\>

namespace Athena {

void LightingPass::Setup(RenderGraphBuilder& builder) {  
    // TODO: ãƒªã‚½ãƒ¼ã‚¹å®£è¨€  
}

void LightingPass::Execute(RenderContext& context) {  
    // TODO: ãƒ©ã‚¤ãƒ†ã‚£ãƒ³ã‚°  
}

std::vector\<std::string\> LightingPass::GetInputs() const {  
    return {"GBuffer\_Albedo", "GBuffer\_Normal", "GBuffer\_Depth"};  
}

std::vector\<std::string\> LightingPass::GetOutputs() const {  
    return {"LitScene"};  
}

ATHENA\_REGISTER\_PASS(LightingPass);

} // namespace Athena

---

## **ãƒ“ãƒ¥ãƒ¼ã‚¢ãƒ¼ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³**

### **ViewerApp**

**AthenaViewer/ViewerApp.h**

\#pragma once  
\#include \<Athena/Core/Device.h\>  
\#include \<Athena/Core/CommandQueue.h\>  
\#include \<Athena/Core/SwapChain.h\>  
\#include \<Athena/RenderGraph/RenderGraph.h\>  
\#include \<Athena/Scene/Scene.h\>  
\#include \<Athena/Scene/Camera.h\>  
\#include "UI/ImGuiManager.h"

namespace Athena {

class ViewerApp {  
public:  
    ViewerApp();  
    \~ViewerApp();  
      
    void Initialize();  
    void Run();  
    void Shutdown();  
      
private:  
    void ProcessInput();  
    void Update(float deltaTime);  
    void Render();  
    void RenderUI();  
      
    // ã‚³ã‚¢  
    Device device;  
    CommandQueue commandQueue;  
    SwapChain swapChain;  
      
    // ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°  
    RenderGraph renderGraph;  
    Scene scene;  
    Camera camera;  
      
    // UI  
    ImGuiManager imguiManager;  
      
    // ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦  
    HWND hwnd \= nullptr;  
    bool running \= true;  
      
    // çŠ¶æ…‹  
    bool showDebugPanel \= true;  
    bool showPerformance \= true;  
      
    void CreateWindow();  
    void DestroyWindow();  
    void SetupRenderGraph();  
      
    static LRESULT CALLBACK WindowProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);  
};

} // namespace Athena

**AthenaViewer/ViewerApp.cpp**

\#include "ViewerApp.h"  
\#include "UI/DebugPanel.h"  
\#include "UI/PerformancePanel.h"  
\#include \<Athena/Utils/Logger.h\>

namespace Athena {

ViewerApp::ViewerApp() \= default;  
ViewerApp::\~ViewerApp() \= default;

void ViewerApp::Initialize() {  
    Logger::Info("Initializing Athena Viewer...");  
      
    // ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ä½œæˆ  
    CreateWindow();  
      
    // ãƒ‡ãƒã‚¤ã‚¹åˆæœŸåŒ–  
    device.Initialize(true);  
      
    // ã‚³ãƒãƒ³ãƒ‰ã‚­ãƒ¥ãƒ¼åˆæœŸåŒ–  
    commandQueue.Initialize(device.GetD3D12Device(), D3D12\_COMMAND\_LIST\_TYPE\_DIRECT);  
      
    // ã‚¹ãƒ¯ãƒƒãƒ—ãƒã‚§ãƒ¼ãƒ³åˆæœŸåŒ–  
    swapChain.Initialize(  
        device.GetDXGIFactory(),  
        commandQueue.GetD3D12CommandQueue(),  
        hwnd,  
        1920, 1080  
    );  
      
    // ImGuiåˆæœŸåŒ–  
    imguiManager.Initialize(\&device, hwnd);  
      
    // ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚°ãƒ©ãƒ•ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—  
    SetupRenderGraph();  
      
    Logger::Info("Athena Viewer initialized successfully");  
}

void ViewerApp::Run() {  
    MSG msg \= {};  
      
    while (running) {  
        // ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å‡¦ç†  
        while (PeekMessage(\&msg, nullptr, 0, 0, PM\_REMOVE)) {  
            TranslateMessage(\&msg);  
            DispatchMessage(\&msg);  
              
            if (msg.message \== WM\_QUIT) {  
                running \= false;  
            }  
        }  
          
        if (\!running) break;  
          
        // æ›´æ–°  
        ProcessInput();  
        Update(0.016f); // ä»®ã® deltaTime  
          
        // ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°  
        Render();  
    }  
}

void ViewerApp::Shutdown() {  
    Logger::Info("Shutting down Athena Viewer...");  
      
    // GPUå¾…æ©Ÿ  
    commandQueue.WaitForGPU();  
      
    // çµ‚äº†å‡¦ç†  
    renderGraph.Clear();  
    imguiManager.Shutdown();  
    swapChain.Shutdown();  
    commandQueue.Shutdown();  
    device.Shutdown();  
      
    DestroyWindow();  
}

void ViewerApp::ProcessInput() {  
    // TODO: å…¥åŠ›å‡¦ç†  
}

void ViewerApp::Update(float deltaTime) {  
    // TODO: ã‚«ãƒ¡ãƒ©æ›´æ–°ãªã©  
}

void ViewerApp::Render() {  
    // TODO: ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°å®Ÿè£…  
      
    // UIæç”»  
    RenderUI();  
      
    // ãƒ—ãƒ¬ã‚¼ãƒ³ãƒˆ  
    swapChain.Present(true);  
}

void ViewerApp::RenderUI() {  
    imguiManager.NewFrame();  
      
    // ãƒ‡ãƒãƒƒã‚°ãƒ‘ãƒãƒ«  
    if (showDebugPanel) {  
        DebugPanel::Render(renderGraph, scene, showDebugPanel);  
    }  
      
    // ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ‘ãƒãƒ«  
    if (showPerformance) {  
        PerformancePanel::Render(showPerformance);  
    }  
      
    imguiManager.Render(nullptr); // TODO: CommandListæ¸¡ã™  
}

void ViewerApp::CreateWindow() {  
    // TODO: Win32ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ä½œæˆ  
}

void ViewerApp::DestroyWindow() {  
    if (hwnd) {  
        DestroyWindow(hwnd);  
        hwnd \= nullptr;  
    }  
}

void ViewerApp::SetupRenderGraph() {  
    // TODO: ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚°ãƒ©ãƒ•æ§‹ç¯‰  
    renderGraph.Compile();  
}

LRESULT CALLBACK ViewerApp::WindowProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam) {  
    // TODO: ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ãƒ—ãƒ­ã‚·ãƒ¼ã‚¸ãƒ£  
    return DefWindowProc(hwnd, msg, wParam, lParam);  
}

} // namespace Athena

### **main.cpp**

**AthenaViewer/main.cpp**

\#include "ViewerApp.h"  
\#include \<Athena/Utils/Logger.h\>  
\#include \<exception\>

int WINAPI WinMain(  
    HINSTANCE hInstance,  
    HINSTANCE hPrevInstance,  
    LPSTR lpCmdLine,  
    int nCmdShow) {  
      
    try {  
        Athena::Logger::Initialize();  
          
        Athena::ViewerApp app;  
        app.Initialize();  
        app.Run();  
        app.Shutdown();  
          
        Athena::Logger::Shutdown();  
        return 0;  
    }  
    catch (const std::exception& e) {  
        Athena::Logger::Error("Fatal error: %s", e.what());  
        MessageBoxA(nullptr, e.what(), "Error", MB\_OK | MB\_ICONERROR);  
        return 1;  
    }  
}

---

## **ç ”ç©¶æ©Ÿèƒ½ã®è¿½åŠ æ–¹æ³•**

### **æ–°ã—ã„ãƒ¬ãƒ³ãƒ€ãƒ¼ãƒ‘ã‚¹ã®ä½œæˆ**

// AthenaResearch/NeuralRendering/NeuralGIPass.h  
\#pragma once  
\#include \<Athena/RenderGraph/RenderPass.h\>

namespace Athena::Research {

class NeuralGIPass : public RenderPass {  
public:  
    NeuralGIPass();  
      
    void Setup(RenderGraphBuilder& builder) override;  
    void Execute(RenderContext& context) override;  
      
    std::vector\<std::string\> GetInputs() const override;  
    std::vector\<std::string\> GetOutputs() const override;  
    const char\* GetName() const override { return "NeuralGIPass"; }  
      
private:  
    void LoadNetwork(const std::string& path);  
    void RunInference(RenderContext& context);  
};

ATHENA\_REGISTER\_PASS(NeuralGIPass);

} // namespace Athena::Research

### **è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã§ã®ä½¿ç”¨**

// configs/neural\_gi.json  
{  
    "name": "Neural GI Experiment",  
    "description": "Real-time GI using neural networks",  
    "passes": \[  
        {  
            "type": "GeometryPass",  
            "enabled": true  
        },  
        {  
            "type": "NeuralGIPass",  
            "enabled": true,  
            "config": {  
                "modelPath": "models/gi\_network.onnx"  
            }  
        },  
        {  
            "type": "LightingPass",  
            "enabled": true  
        }  
    \]  
}

---

## **å®Ÿé¨“ãƒ»ãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯**

### **ãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯ã®å®Ÿè¡Œ**

// experiments/benchmark\_runner.cpp  
\#include \<Athena/Athena.h\>  
\#include \<vector\>  
\#include \<string\>

int main(int argc, char\*\* argv) {  
    using namespace Athena;  
      
    // åˆæœŸåŒ–  
    Device device;  
    device.Initialize(false); // ãƒ‡ãƒãƒƒã‚°ãƒ¬ã‚¤ãƒ¤ãƒ¼OFF  
      
    // ãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯å¯¾è±¡ã®è¨­å®š  
    std::vector\<std::string\> configs \= {  
        "configs/standard.json",  
        "configs/neural\_gi.json",  
        "configs/gpu\_driven.json"  
    };  
      
    // å„è¨­å®šã§ãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯  
    for (const auto& config : configs) {  
        Logger::Info("Benchmarking: %s", config.c\_str());  
          
        // TODO: ãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯å®Ÿè¡Œ  
    }  
      
    return 0;  
}

---

## **é–‹ç™ºãƒ•ãƒ­ãƒ¼**

### **ãƒ•ã‚§ãƒ¼ã‚º1: åŸºç›¤é–‹ç™º**

ç›®æ¨™: ä¸‰è§’å½¢ã‚’è¡¨ç¤º

å®Ÿè£…å†…å®¹:  
1\. DeviceåˆæœŸåŒ–  
2\. CommandQueueä½œæˆ  
3\. SwapChainä½œæˆ  
4\. åŸºæœ¬çš„ãªã‚³ãƒãƒ³ãƒ‰ãƒªã‚¹ãƒˆå®Ÿè¡Œ  
5\. å˜ç´”ãªé ‚ç‚¹ãƒ»ãƒ”ã‚¯ã‚»ãƒ«ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼  
6\. ä¸‰è§’å½¢æç”»

ç¢ºèªäº‹é …:  
âœ“ ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã«ä¸‰è§’å½¢ãŒè¡¨ç¤ºã•ã‚Œã‚‹  
âœ“ PIXã§ã‚­ãƒ£ãƒ—ãƒãƒ£ã§ãã‚‹  
âœ“ ãƒ¡ãƒ¢ãƒªãƒªãƒ¼ã‚¯ãŒãªã„

### **ãƒ•ã‚§ãƒ¼ã‚º2: ãƒªã‚½ãƒ¼ã‚¹ç®¡ç†**

ç›®æ¨™: ãƒ†ã‚¯ã‚¹ãƒãƒ£ä»˜ãã‚­ãƒ¥ãƒ¼ãƒ–

å®Ÿè£…å†…å®¹:  
1\. BufferæŠ½è±¡åŒ–  
2\. TextureæŠ½è±¡åŒ–  
3\. DescriptorHeapç®¡ç†  
4\. ResourceManager  
5\. é ‚ç‚¹ãƒ»ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãƒãƒƒãƒ•ã‚¡  
6\. å®šæ•°ãƒãƒƒãƒ•ã‚¡(MVPè¡Œåˆ—)  
7\. ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°

ç¢ºèªäº‹é …:  
âœ“ ã‚­ãƒ¥ãƒ¼ãƒ–ãŒå›è»¢ã™ã‚‹  
âœ“ ãƒ†ã‚¯ã‚¹ãƒãƒ£ãŒæ­£ã—ãè¡¨ç¤ºã•ã‚Œã‚‹  
âœ“ æ·±åº¦ãƒ†ã‚¹ãƒˆãŒå‹•ä½œ

### **ãƒ•ã‚§ãƒ¼ã‚º3: ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚°ãƒ©ãƒ•**

ç›®æ¨™: æŸ”è»Ÿãªãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³æ§‹æˆ

å®Ÿè£…å†…å®¹:  
1\. RenderPassåŸºåº•ã‚¯ãƒ©ã‚¹  
2\. RenderGraphæœ¬ä½“  
3\. ä¾å­˜é–¢ä¿‚è§£æ±º  
4\. ãƒªã‚½ãƒ¼ã‚¹ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ ç®¡ç†  
5\. PassRegistry  
6\. æ¨™æº–ãƒ‘ã‚¹å®Ÿè£…

ç¢ºèªäº‹é …:  
âœ“ ãƒ‘ã‚¹ã®å‹•çš„è¿½åŠ ãƒ»å‰Šé™¤  
âœ“ ä¾å­˜é–¢ä¿‚ã®è‡ªå‹•è§£æ±º  
âœ“ è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰æ§‹ç¯‰

### **ãƒ•ã‚§ãƒ¼ã‚º4: ã‚·ãƒ¼ãƒ³ç®¡ç†**

ç›®æ¨™: 3Dãƒ¢ãƒ‡ãƒ«è¡¨ç¤º

å®Ÿè£…å†…å®¹:  
1\. Mesh / Material  
2\. Camera  
3\. Light  
4\. Sceneç®¡ç†  
5\. Assimpçµ±åˆ(ãƒ¢ãƒ‡ãƒ«ãƒ­ãƒ¼ãƒ€ãƒ¼)

ç¢ºèªäº‹é …:  
âœ“ OBJ/FBXãƒ¢ãƒ‡ãƒ«ã®èª­ã¿è¾¼ã¿  
âœ“ ã‚«ãƒ¡ãƒ©æ“ä½œ(FPSé¢¨)  
âœ“ è¤‡æ•°ãƒ¡ãƒƒã‚·ãƒ¥ã®æç”»

### **ãƒ•ã‚§ãƒ¼ã‚º5: ãƒ“ãƒ¥ãƒ¼ã‚¢ãƒ¼**

ç›®æ¨™: ä½¿ã„ã‚„ã™ã„å®Ÿé¨“ç’°å¢ƒ

å®Ÿè£…å†…å®¹:  
1\. ImGuiçµ±åˆ  
2\. DebugPanel  
3\. PerformancePanel  
4\. å…¥åŠ›å‡¦ç†  
5\. ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ãƒ§ãƒƒãƒˆæ©Ÿèƒ½

ç¢ºèªäº‹é …:  
âœ“ UIã§è¨­å®šå¤‰æ›´  
âœ“ ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒªãƒ³ã‚°  
âœ“ ç›´æ„Ÿçš„ãªæ“ä½œ

### **ãƒ•ã‚§ãƒ¼ã‚º6: ç ”ç©¶æ©Ÿèƒ½å®Ÿè£…**

ç›®æ¨™: æ–°è¦ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°æŠ€è¡“ã®å®Ÿè£…

å®Ÿè£…å†…å®¹:  
1\. ç ”ç©¶ç”¨ãƒ‘ã‚¹ä½œæˆ  
2\. ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼é–‹ç™º  
3\. ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿èª¿æ•´  
4\. ãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯å®Ÿæ–½

ç¢ºèªäº‹é …:  
âœ“ åŸºç›¤ã‚’å¤‰æ›´ã›ãšã«å®Ÿè£…  
âœ“ æ—¢å­˜æ‰‹æ³•ã¨ã®æ¯”è¼ƒ  
âœ“ è«–æ–‡ç”¨ãƒ‡ãƒ¼ã‚¿åé›†

---

## **è«–æ–‡åŸ·ç­†ã¸ã®å¿œç”¨**

### **å®Ÿè£…ç« ã®è¨˜è¿°ä¾‹**

\\section{Implementation}

We implemented our method in \\textit{Athena Renderer}, a DirectX 12-based   
rendering framework designed for rapid prototyping of rendering techniques.   
Athena's modular render graph architecture enables researchers to compose   
and evaluate different rendering strategies without modifying core systems.

\\subsection{System Architecture}

Athena consists of four layers (Figure\~\\ref{fig:architecture}):  
\\begin{enumerate}  
    \\item \\textbf{DirectX 12 Abstraction}: Device management, resource   
          allocation, and command execution  
    \\item \\textbf{Render Graph}: Automatic dependency resolution and   
          resource lifetime management  
    \\item \\textbf{Standard Passes}: Geometry, lighting, and post-processing  
    \\item \\textbf{Research Modules}: Novel techniques as pluggable passes  
\\end{enumerate}

Our implementation (\\texttt{NeuralGIPass}) integrates seamlessly into the   
pipeline, requiring no changes to the core framework or other passes.

\\subsection{Performance Profiling}

Athena includes integrated GPU profiling using DirectX 12 timestamp queries,   
enabling precise per-pass timing measurements. All experiments were conducted   
on an NVIDIA RTX 4090 GPU with 24GB VRAM running Windows 11\.

### **å®Ÿé¨“çµæœã®æç¤º**

\\begin{table}\[h\]  
\\centering  
\\caption{Performance Comparison on Sponza Scene (1920Ã—1080)}  
\\begin{tabular}{lccc}  
\\toprule  
Method & Frame Time (ms) & GPU Time (ms) & PSNR (dB) \\\\  
\\midrule  
Standard Raster & 8.2 Â± 0.3 & 7.1 Â± 0.2 & 28.3 \\\\  
SSGI & 15.7 Â± 0.5 & 14.2 Â± 0.4 & 31.8 \\\\  
Neural GI (Ours) & 11.3 Â± 0.4 & 9.8 Â± 0.3 & 33.2 \\\\  
\\bottomrule  
\\end{tabular}  
\\label{tab:performance}  
\\end{table}

Our method achieves 38\\% faster rendering than SSGI while maintaining   
4.4\\% higher image quality (PSNR). Figure\~\\ref{fig:visual\_comparison}   
shows qualitative comparisons.

---

## **ãƒˆãƒ©ãƒ–ãƒ«ã‚·ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚°**

### **ã‚ˆãã‚ã‚‹å•é¡Œ**

#### **1\. ãƒ“ãƒ«ãƒ‰ã‚¨ãƒ©ãƒ¼: "d3d12.h ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“"**

åŸå› : Windows SDK ãŒã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã•ã‚Œã¦ã„ãªã„

è§£æ±ºç­–:  
1\. Visual Studio Installerèµ·å‹•  
2\. å¤‰æ›´ â†’ å€‹åˆ¥ã®ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ  
3\. "Windows 10 SDK" ã¾ãŸã¯ "Windows 11 SDK" ã«ãƒã‚§ãƒƒã‚¯  
4\. å¤‰æ›´ã‚’é©ç”¨

#### **2\. å®Ÿè¡Œæ™‚ã‚¨ãƒ©ãƒ¼: "D3D12CreateDevice failed"**

åŸå› : DirectX 12ã«å¯¾å¿œã—ã¦ã„ãªã„GPU

è§£æ±ºç­–:  
1\. dxdiag ã§ DirectX ãƒãƒ¼ã‚¸ãƒ§ãƒ³ç¢ºèª  
2\. GPU ãƒ‰ãƒ©ã‚¤ãƒãƒ¼ã‚’æœ€æ–°ã«æ›´æ–°  
3\. å¯¾å¿œGPUã¸ã®äº¤æ›

#### **3\. ãƒªãƒ³ã‚¯ã‚¨ãƒ©ãƒ¼: "unresolved external symbol"**

åŸå› : ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®ãƒªãƒ³ã‚¯å¿˜ã‚Œ

è§£æ±ºç­–:  
ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ â†’ ãƒªãƒ³ã‚«ãƒ¼ â†’ å…¥åŠ›  
â†’ è¿½åŠ ã®ä¾å­˜ãƒ•ã‚¡ã‚¤ãƒ«ã«ä»¥ä¸‹ã‚’è¿½åŠ :  
  d3d12.lib  
  dxgi.lib  
  d3dcompiler.lib

#### **4\. ImGuiãŒè¡¨ç¤ºã•ã‚Œãªã„**

åŸå› : ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã®åˆæœŸåŒ–ä¸è¶³

è§£æ±ºç­–:  
1\. imgui\_impl\_win32.cpp ã‚’ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã«è¿½åŠ   
2\. imgui\_impl\_dx12.cpp ã‚’ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã«è¿½åŠ   
3\. åˆæœŸåŒ–é †åºã‚’ç¢ºèª:  
   ImGui\_ImplWin32\_Init()  
   ImGui\_ImplDX12\_Init()

#### **5\. ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã‚¨ãƒ©ãƒ¼**

åŸå› : ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒ¢ãƒ‡ãƒ«ã®ä¸ä¸€è‡´

è§£æ±ºç­–:  
ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£  
â†’ ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒ¢ãƒ‡ãƒ«: 6.0 ä»¥ä¸Šã«è¨­å®š

### **ãƒ‡ãƒãƒƒã‚°ãƒ„ãƒ¼ãƒ«**

1\. PIX for Windows  
   \- GPU ãƒ‡ãƒãƒƒã‚°  
   \- ãƒ•ãƒ¬ãƒ¼ãƒ ã‚­ãƒ£ãƒ—ãƒãƒ£  
   \- ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹åˆ†æ

2\. RenderDoc  
   \- ã‚¯ãƒ­ã‚¹ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ   
   \- è©³ç´°ãªãƒ•ãƒ¬ãƒ¼ãƒ è§£æ

3\. Visual Studio Graphics Debugger  
   \- çµ±åˆç’°å¢ƒ  
   \- ãƒ–ãƒ¬ãƒ¼ã‚¯ãƒã‚¤ãƒ³ãƒˆè¨­å®šå¯èƒ½

---

## **å‚è€ƒè³‡æ–™**

### **å…¬å¼ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ**

* [Microsoft DirectX 12 Programming Guide](https://docs.microsoft.com/en-us/windows/win32/direct3d12/directx-12-programming-guide)  
* [DirectX Graphics Samples](https://github.com/microsoft/DirectX-Graphics-Samples)

### **æ›¸ç±**

* "Introduction to 3D Game Programming with DirectX 12" \- Frank Luna  
* "Real-Time Rendering, 4th Edition" \- Tomas Akenine-MÃ¶ller et al.  
* "Physically Based Rendering" \- Matt Pharr et al.

### **å‚è€ƒå®Ÿè£…**

* [Falcor](https://github.com/NVIDIAGameWorks/Falcor) \- NVIDIA  
* [MiniEngine](https://github.com/microsoft/DirectX-Graphics-Samples/tree/master/MiniEngine) \- Microsoft  
* [AMD Cauldron](https://github.com/GPUOpen-LibrariesAndSDKs/Cauldron)

---

## **ãƒ©ã‚¤ã‚»ãƒ³ã‚¹**

MIT License

Copyright (c) 2025 \[Your Name\]

Permission is hereby granted, free of charge, to any person obtaining a copy  
of this software and associated documentation files (the "Software"), to deal  
in the Software without restriction, including without limitation the rights  
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell  
copies of the Software, and to permit persons to whom the Software is  
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all  
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR  
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE  
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER  
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,  
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE  
SOFTWARE.

---

## **ã¾ã¨ã‚**

Athena Rendererã¯ã€ã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯ã‚¹ç ”ç©¶ã®ãŸã‚ã®æŸ”è»Ÿã§æ‹¡å¼µæ€§ã®é«˜ã„ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ã§ã™ã€‚ã“ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã«å¾“ã£ã¦é–‹ç™ºã‚’é€²ã‚ã‚‹ã“ã¨ã§:

âœ… **å …ç‰¢ãªåŸºç›¤**: DirectX 12ã®æ·±ã„ç†è§£ âœ… **ç ”ç©¶ã®è‡ªç”±**: åŸºç›¤ã‚’å¤‰ãˆãšã«æ–°æ©Ÿèƒ½è¿½åŠ  âœ… **è«–æ–‡åŸ·ç­†**: å®Ÿé¨“ãƒ‡ãƒ¼ã‚¿ã®è‡ªå‹•åé›† âœ… **æŠ€è¡“åŠ›è¨¼æ˜**: ãƒãƒ¼ãƒˆãƒ•ã‚©ãƒªã‚ªä½œå“ã¨ã—ã¦

çŸ¥æµã®å¥³ç¥ã‚¢ãƒ†ãƒŠã®ã‚ˆã†ã«ã€è³¢æ˜ã«æŠ€è¡“ã‚’æ¢æ±‚ã—ã€ç´ æ™´ã‚‰ã—ã„ç ”ç©¶æˆæœã‚’ç”Ÿã¿å‡ºã—ã¦ãã ã•ã„ã€‚

---

**Athena Renderer Development Team** **Version 1.0 \- 2025**

